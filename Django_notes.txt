Django Notes

path: /g/My Drive/python/tms

----------------------------------------------------------------------------------------------------------------------------------------------------------------

HTTP -> Hypertext Transfer Protocol and is used to structure requests and responses over the internet

The transfer of resources happens using TCP (Transmission Control Protocol).

URL -> Uniform Resource Locator

Django comes with an admin panel, a user authentication system, a database, and something called object-relational mapper (ORM) 
that helps a web application interact with a database. These are some of the “batteries” included in Django to help build projects 
faster without having to worry about which tools to use.


The Django project describes itself as an MTV framework, using Models, Templates and Views.

* The model portion deals with data and databases, it can retrieve, store, and change data in a database.

* The template determines how the data looks on a web page.

* The view describes the data to be presented, and passes this information to the template.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

STARTING A DJANGO PROJECT

* django-admin <command> [options] ->  Django provides us with django-admin, a command-line utility that helps us with a variety of administrative tasks.

* django-admin help -> Running django-admin help will provide a list of possible commands.

* django-admin startproject <projectname> -> A Django project can be easily created with the startproject command. It takes a couple of 
  options– the name of the project and optionally the directory for our project.


Django will then create a directory for the project, or the project root folder.

* Inside the project root folder is a Python file, manage.py, that contains a collection of useful functions used to administer the project. This file 
  performs the same actions as django-admin but is set specifically to the project.

* Alongside the manage.py is another directory with the same name as the project. This folder is treated as a Python package because of the presence
  of __init__.py, and inside this directory contains important settings and configuration files for the project.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONFIGURING DJANGO SETTINGS

## Important for us are settings.py and urls.py ##

Since the project comes pre-configured, we can start a server to test that the project works. 

A development server can be started by using manage.py and providing the runserver command. 

This command must be run in the root directory, the same directory where manage.py is located. 

By default, Django will start a development server with port 8000, but an alternate port can be provided as an option.


* python3 manage.py runserver <port_number>


The Django development server will hot-reload as changes are made to the project, so we don’t have to keep restarting the server as we develop. 

* The server will keep running until we stop it with the ctrl + c.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MIGRATING THE DATABASE 

A migration is a pending database change. As we saw in settings.py, by default, Django will have some apps installed. 

Some of these default apps, for example, the admin interface, use the database and the migrations must be applied to the SQLite database.


* Whenever we make changes to the model of the database, we must apply the changes by running python3 manage.py migrate


By applying our migration, we have access to the admin app! The admin app comes pre-installed and can be navigated to since it has its URL 
provided in urls.py we saw earlier. 

At the moment there aren’t any admin users but we can still visit localhost/admin to see the admin login page.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

DJANGO APPS

A Django app is a submodule to a project, that contains the code for a specific feature.

In the submodule, we’ll find things like: a models.py file, a migration directory, and other files and directories related to the application.

A Django app can be created by running the startapp command in the project root directory, the directory with manage.py, and providing the name 
of the app as an additional option.

* python3 manage.py startapp myapp

In order for Django to be aware of the app’s existence, it needs to be added to the list of INSTALLED_APPS in the project’s settings.py file.

INSTALLED_APPS = [
  "myapp.apps.MyappConfig"
]

AFTER CREATING AN APP YOU NEED TO ADD IT TO THE INSTALLED_APP LIST


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A VIEW FOR AN APP

Views are the information brokers in a Django application that decides what data gets delivered to a template and displayed.

*  A view is a class or function that processes a request and sends a response back.

The view function may:

1) Check to see if the customer is logged in

2) Request their profile information from a database

3) Format the information in a template

4) Send back the profile page as an HTML file for the customer to view in their browser


In Django, requests, and responses are handled as HttpRequest and HttpResponse objects from a module called django.http.


When a page is requested:
1) Django creates an HttpRequest object that contains information about the request

2)Django loads the appropriate view, passing the HttpRequest as the first argument to the view function


Each view function is responsible for returning an HttpResponse object. The HttpResponse response object can be the HTML 
contents of a web page, a redirect, an error, an XML document, an image, or just about anything that can display on a web page.


A simple view function would look like this:

def index(request):
	return HttpResponse("this is the response!")


THE FUNCTIONS MUST BE WRITTEN INSIDE views.py code


----------------------------------------------------------------------------------------------------------------------------------------------------------------

USING A VIEW TO SEND AN HTML PAGE 


We can use Django to render an HTML page when a view function is called. 

Django will look in each app folder inside INSTALLED_APPS for directories named templates. 

* That is to place our HTML pages inside a directory that has the same name as your app within the templates/ directory.


The resulting folder structure will look like this:

projectname/
 |-- appname/
     |-- templates/
          |-- appname/
              |-- first_template.html



View to send an HTML page:

###

from django.template import loader

def home():
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render())

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A DJANGO TEMPLATE


To place content generated from Django inside the HTML file, we need to turn our static HTML file into a template.


In the context of a web framework, templates are pages created with special markup that allows for backend data and 
commands to modify the contents of a page.


Django employs a special syntax called Django Templating Language to distinguish itself from HTML, CSS, and JavaScript.


That syntax in many template languages uses curly braces, sometimes referred to as handlebars, as a placeholder for data 
that is passed by Django.


In HTML, we use curly braces like this: inside the app template

<h1>Hello, {{name}}</h1>


When we call the view to render the template, we can use something called a context to tell Django what to replace in the template


The relationships in the context are referred to as a name/value pair. By default, a context is an empty dictionary.


* context = {"name": "Junior"}


We then pass the context as an argument in the render function inside of view.py.


###

from django.http import HttpResponse
from django.template import loader

def home(request):
  context = {"name": "Junior"}
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render(context))

###

This would return a webpage that says “Hello, Junior” inside an <h1> tag.


It’s quite common in Django to load templates, fill their context, and return an HttpResponse object with their rendered template. 


Django provides a shortcut for this pattern called the render() function! The render() function will do the work of loading the
template and provide the contexts when they are passed as arguments.


###

from django.shortcuts import render
 
def home(request):
  context = {"name": "Junior"}
  return render(request, "app/home.html", context)

###


The render() function takes the request object as its first argument, a template name as its second argument, and a dictionary 
as an optional third argument that passes the context variables to the template.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

WIRING UP A VIEW

On the internet, every page needs its own URL because each URL displays unique information.

In Django, we can use something called a URLconf, for URL configuration.

An app’s URLconf is located in a file named urls.py inside the app’s directory.

At the top of the urls.py we import the path object from django.urls and we import the view functions from views.py and 
add routes that direct to each of our view functions.


urls.py will look like this:

###

from django.urls import path
from . import views
 
urlpatterns = [
  path('', views.home),
  path('profile/', views.profile, name="profile")  
]

###


After the import statements is a list of patterns called urlpatterns, which contain the routes to each view function.


Each route is provided as a path() object that has three arguments: the URL route as a string, the name of the function 
of the view, and an optional name used to refer to the view.


To make Django aware of the app’s URLconf, it must be included in the project’s URLconf, also called urls.py.


The default urls.py folder for a project looks like this:

###

from django.contrib import admin
from django.urls import path
 
urlpatterns = [
  path("admin/", admin.site.urls),
]

###


To include the app’s URLconf we import the include path from django.urls and add a path()to the urlpatterns.

###

from django.contrib import admin
from django.urls import include, path
 
urlpatterns = [
  path("admin/", admin.site.urls),
  path("", include("myapp.urls")),
]

###


With both URLconfs set up, we can properly view our routes for the application: myapp in a web browser.


*** You have to create a urls.py file inside the app forlder and also create the urls paths inside the urls.py file from the project directory



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORTUNE TELLER - PROJECT

1) start new project 

* django-admin startproject fortuneteller



2) change directory to the fortuneteller project just created and run the migrate command

* cd fortuneteller

* python3 manage.py migrate



3) run the server to check for errors

* python3 manage.py runserver 0.0.0.0:4001 

to stop the development server -> ctrl + c



4) create a new app inside the project: "randomfortune"

* python3 manage.py startapp randomfortune



5) add the new app <randomfortune> to the list of installed apps for our Django project to be aware of it.

inside of settings.py (inside the project folder): find the list named INSTALLED_APPS and add the config file for randomfortune
by inlcuiding:

"randomfortune.apps.RandomfortuneConfig" to the list.


6) create a template: 

First, we will create the template directories to namespace the template. 

Inside the project app directory, randomfortune/, create a folder named, templates. 
Next, within the newly created, templates/, create a folder named randomfortune to namespace our template file.

crate the file fortune.html which contains the template html code. 

now we need to create the view functions and the URLconfig to watch it on the web app.


7) Create a view function.


To send fortune.html to our client, we’ll write a view function and send it when the page is requested.

Inside the randomfortune app, open views.py. Define a new function named fortune() that takes a single parameter, request.

In fortune(), return the render function with two arguments, the request and the path to fortune.html 
as a string, "randomfortune/fortune.html".

###

from django.shortcuts import render

# Create your views here.
def fortune(requst):
  return render(request, "randomfortune/fortune.html")

###


8) Wire up view.

Our fortune() view function sends back fortune.html when called. We’ll need to tell Django which URL we want to direct to this function.

First, create the URLconf for the randomfortune app by creating a file named urls.py inside the app directory.



Inside urls.py, we’ll need to import a couple of things to call the view function when the URL is requested.

At the top of urls.py import:

-> path module from django.urls

-> the functions from views.py.


###

from django.urls import path
from django.urls import views

urlpatterns = [
  path("", views.fortune)
]

###


9) Now that we have our app’s URLconfig setup, we will have to import it in the project’s URLconfig for the URLs to be picked 
up by the Django project.


We’ll have to import the include module to include the URL configuration file.


Inside fortuneteller/fortuneteller, import the include module from django.urls.

In the existing urlpatterns list, add another path() with the arguments:

"" to reference the home page

include() with randomfortune‘s URLs as a string.

###

from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("", include("randomfortune.urls"))
]

###


10) Sending a Context to the Template


Create a list of fortunes named fortuneList inside our app’s views.py file. Define it outside of the fortune() function.

To select a random fortune from the list we’ll use a built-in Python function, random.choice().

###

def fortune(request):
  fortune = random.choice(fortuneList)
  context = {"fortune", fortune}
  return render(request, "randomfortune/fortune.html", context)

###


Great! We now have a random fortune stored in fortune. To send it to the HTML template, we’ll create 
a context variable to send with the template.



11) Render context inside template


The last step to render the fortune in the template is to use the Django template language to replace 
the placeholder text. Inside fortune.html, between the <p></p> tags, replace the text with {{ fortune }}.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

TEMPLATES

The Convenience of templates:

Django uses templates to display information to users. In conventional web development, web pages are written with HTML.

Rather, Django gives us Django Template Language (DTL) which lets us inject variables, logic, and control flow inside of our HTML - supercharging 
our HTML files to do so much more than provide static content.

Django Template Language (DTL) -> https://docs.djangoproject.com/en/3.1/ref/templates/language/

In Django, templates are going to be the user facing content. However, Django templates usually have added 
Django Template Language, or DTL, modifications.

In order to create templates, they have to be stored in the application in a folder called templates/. 

Another folder needs to be created inside of this templates/ folder that uses the same name of the application. All of the templates will 
go into this folder named after the application. 



----------------------------------------------------------------------------------------------------------------------------------------------------------------

REVISITING OUR FIRST TEMPLATE

The first template usually made is the homepage of the application. 

Templates can be plain HTML files and are stored inside of appname/templates/appname/.

When any template is referenced later, it will be done by calling appname/template_name.html. 

Once the template is made, some of the code in views.py will have to be modified in order to render the template.

Rendering the template is the Django application taking the template and displaying it as a normal HTML page in a web browser.

Inside of views.py, we need functions, or classes, that tell the template what information to include.

Just as a refresher, the final method in views.py should look like the one below:

###

def homepage(request):
  return render(request, "app_name/sample_template.html")

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A BASE TEMPLATE

An basic navigation bar looks like the following:

###

<div class="topnav" id="pageTopNav">
  <a href="#home" class="active">Home</a>
  <a href="#contact">Contact</a>
</div>

###


A base template is created the same way as a normal template, starting with an HTML file. 

By convention, the base template is usually called something like base.html or base_template.html.

Once the common elements have been moved to base.html, we can start talking about adding page-specific content.

Since the base.html will be used across several templates, we need to tell the application where we want our page-specific content to go.

To do this, we add tags to the body of the base template. Tags are used to help extend the base template to other templates.

tags are created using the {% and %} symbols.

Inside of these tags, we’ll be adding block content, and later another tag with the content endblock.

This creates a block that we can add code to in other templates. This block gives us the ability to later insert content 
that is specific to individual pages. It should look like this:

###

{% block content %}
 
{% endblock %}

###


Typically only page-specific content will go inside of these tags and is added from other templates. These blocks are usually 
left empty in the base template though. Multiple blocks can be created within the base template and then used in other templates.

base.html:

###

<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <h1>Welcome to Vet Office!</h1>
    {% block content %}

    {% endblock %}
  </body>

</html>

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

EXTENDING THE BASE TEMPLATE

We can refactor our other templates by removing the common elements.

###

{% extends "vetoffice/base.html" %}
 
{% block content %}
<p>This will go inside the body</p>
 
<p>This will also be inside the body</p>
{% endblock %}

###

----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING CSS TO THE TEMPLATES

We need a folder to store our CSS files, this folder will be in the application’s main folder and called static/. 


This folder will hold assets like pictures and CSS files. Another folder will be created inside of static/ that will be named after our application.

The full path should look like the one below:


projectname/
 |-- appname/
     |-- templates/
     |-- static/
         |-- appname/
             |-- file.css


Once a CSS file is added to static/appname, it can be referenced within our templates inside of blocks 
formed in the base.html <head> elements. 

This is because static files will not be passed down to children of the base.html template. 

The files in our static/ folder should be loaded in the <header>. 

Therefore, we’ll add another block tag, like so:


###

<!-- base.html -->
<!DOCTYPE html>
<head>
  {% block head %}
 
  {% endblock %}
</head>
...

###


Inside of the template we’ll be using, we first need to load in static files. 

This is typically done at the beginning of the file after extending from base.html.

This will let us access all of our static files later. Then the block created from base.html can be added to the document.

This is the block where the CSS will be loaded in. This is done by loading a CSS file as normal, 
except setting the href to a tag that says {% static 'appname/file.css' %}. 

It should look like the code below.

###

<!-- template_example.html -->
{% load static %}
 
{% block head %}
<link rel="stylesheet" href="{% static 'appname/file.css' %}">
{% endblock %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

VARIABLES IN TEMPLATES

DTL can do so much more for us, like grabbing variables from views.py, creating loops, if statements, 
and more! In this exercise, we’ll start with creating variables.

The syntax for evaluating variables — two symbols are needed, {{ and }}, we call these symbols variable tags. 

When we add a variable in between variable tags, Django knows that we want the value of that variable from our views.py file.

###

<p>Welcome, {{ name }}!</p>

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONDITIONALS IN TEMPLATES

Now that we have covered variables, we can start using if statements. 

These if statements help customize web pages without having to create separate templates for different instances.

An if statement in DTL is very similar to Python if statements. 

However, they consist of two necessary components and two optional components. 



The major components are:

+ An if keyword is used in every if statement and its purpose is the same as in Python.

+ An endif keyword is used to let DTL know that we are at the end of the if statement.



The two optional components are:

+ elif - which is used if we want to check more than one condition within the if statement.

+ else - which will execute whenever the if and all elifs evaluates as false. It will be the last thing 
included in an if statement before the endif.



To add an if statement to the template, we’ll need to set it up inside of tags. 

Remember, tags are the {% and %} symbols we used earlier for extending our base template to other templates.

Generally, tags are used to tell the DTL that an expression needs to be executed or evaluated. 

There is no need to use separate variable tags when accessing a variable in normal tags. 


###

{% if city.name == "New York" %}
  <p>Attractions for New York City are</p>
  ...
{% elif city.name == "Los Angeles" %}
  <p>Attractions for Los Angeles are</p>
  ...
{% else %}
  <p>We currently do not have any attractions for that city</p>
{% endif %}

###


Notice that we can use the same {% %} tags to create these conditionals within the template, and 
help tell the DTL what to render. This makes sure that only certain elements get rendered based off the conditionals detailed.

home.html example code:

###

{% extends "vetoffice/base.html" %}
{% load static %}

{% block head %}
  <link rel="stylesheet" href="{% static 'vetoffice/style.css' %}">
{% endblock %}

{% block content %}
  <p>Welcome, {{name}}!</p>
  <!-- Add your if statement below: -->
{% if pet.animal_type == "Dog" %}
  <p>The animal is a dog</p>
{% elif pet.animal_type == "Cat" %}
  <p>The animal is a cat</p>  
{% else %}
  <p>The animal is not a dog or cat</p>
{% endif %}  

{% endblock %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

LOOPS IN TEMPLATES

Loops in DTL work like regular Python for loops but still require tags.

To write a loop in DTL we’ll need to use our tags {% %} and insert the syntax for a for loop. The syntax to start a for loop requires:


1) The for keyword.

2) The name of the new variables we’ll be creating in the loop.

3) An indicator saying in

4) The list we’ll be using in the loop.


Those will all be listed out in that order, and will be followed with an {% endfor %} at the end of the loop. The loop syntax looks like:

###

{% for item in list_name %}
  <p>{{ item }}</p>
{% endfor %}

###

Inside the loop’s body, during each iteration, we can access the current key using the temporary variable key inside variable tags {{ }}. 
We’re free to manipulate the key as a variable using standard Python syntax. If our list contains dictionaries, we could even access the 
value of our dictionary if we change our loop:

###

{% for key, value in dictionary_list %}
  <p>{{ key }} : {{ value }}</p>
{% endfor %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING URLS TO TEMPLATE


When navigating between pages using HTML, we need the entire URL to be written out in a <a> element’s href attribute. With Django, rather 
than using the full URL we get a shortcut by using tags and the name of predefined paths!

Basic shortcut:

###

<a href="{% url 'path_name' %}">Sample link</a>

###


As can be seen above, the link looks very similar to a typical HTML link, except we modify the href to be set to a tag much like we did with CSS files. 
This tag is set to the type url followed by the path name as a string.


When a path requires arguments to get to, like a username, it can be added to the href after the path. We won’t go into detail regarding this, 
but it would look like this:

###

<a href="{% url 'path_name' username %}">User Profile</a>

###

In this case, arguments provide additional information to the URL to access more specific pages. Some DTL functions require arguments while they can 
be optional in other places. The URL is a good instance of where arguments are optional, but not necessary unless the path has an argument.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FILTERS IN TEMPLATES


With Django, variables can be modified from within the template using a filter. 
Filters modify variables passed in from views.py without the use of traditional methods like JavaScript

An example filter can be seen below:

###

<p>{{ username|upper }}</p>

###


The filter is added onto a variable by using the | symbol inside of the variable tags with the variable. 
The symbol goes after the variable name, and is followed by the filter that you want to use


Some filters also require arguments, however, arguments are handled differently with filters compared to 
how we handled arguments with URL. A filter with an argument can be seen here:


###

{{ description|truncatewords_html:2 }}

###


The truncatewords_html filter requires an argument and will shorten text down to the integer supplied by our argument. 
In our case, we want to display 2 words max. Any other words in the description variable will be replaced with .... 
We were able to supply our argument after the filter name separated by a :.


Some filters also require certain data types in order to work. For instance, the time filter requires a variable 
of data type datetime.datetime.Now(), and will not work with any other data type. It is recommended to check out the 
documentation for a filter before using it to make sure you are using the proper data types and adding any necessary arguments.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

REVIEW TEMPLATES

Templates are a great way to reduce the amount of HTML that needs to be written in a website by allowing us to extend templates into the rest of the website 
to reduce repeat code. The options provided to us can help us in a number of ways including:

* Common elements should go inside of a base template, and any page-specific content should be in their own templates.

* Static files have to be loaded in the template they’ll be used in, as it won’t be passed on to child templates.

* Templates can also use DTL to help display variables, loop through and display dictionaries, and create conditionals within templates to reduce the number of templates needed for an application.

* CSS files can be added to a template after adding a static/ folder to the application. Remember that inside of static/ there should be another folder named after the application.

* Variables are great for grabbing data from views.py to display in a template.
  if statements can be used in DTL to conditionally display content.

* DTL can use for loops to go through lists.

* URLs can be referenced with just the path name if the page is within the application. This only works with predefined paths and you should watch for any arguments that need to be passed.

* Filters are useful for modifying variables within a template as you won’t have to write too much extra code to modify the variable yourself.

* Some filters require arguments, so make sure that any filter used does not require any arguments.

* Some filters also only work with specific data types, so make sure to research a filter before using one by looking at the documentation for the filter.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MODELS AND DATABASES

CREATING A MODEL

Every time we create a new app, Django provides us with a folder structure for our work which includes a file called models.py with the following starter code:

###

from django.db import models

###


To create a model, we write a class, like so:

###

class Flower(models.Model):
  ## Define attributes here
  pass

###

Notice that our model actually inherits from the Model parent class django.db.models.Model module. These models will later inform the 
database to use this schema to build its tables


model.py example:

###

from django.db import models

# Create your models here.
class Owner(models.Model):
  pass

class Patient(models.Model):
  pass

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING MODEL FIELDS

As we mentioned, models are used to represent real-life objects. We can mimic and create object attributes in our models using fields. 

Fields have names and are assigned a type. For example, a Flower model can have a petal_color field that expects a string:

###

class Flower(models.Model):
  petal_color = models.CharField()

###


Django uses specific field types to match the expected data with what will go into the database. 

Above, we used the .CharField() type to store a short string. We can continue to add to our model and include other attributes, like petal_number.


###

class Flower(models.Model):
  petal_color = models.CharField()
  petal_number = models.IntegerField()
  # More attributes… 

###


Since we want petal_number to be a number, we used the .IntegerField() field type. 
Django provides a huge variety of field types for us to specify the data types of our model attributes, check out theField Types Documentation to 
explore the entire list of possibilities!

https://docs.djangoproject.com/en/3.1/ref/models/fields/#model-field-types


We might also want to add constraints to our fields. 

For example, we might want our petal_color field to have a max length of 20 characters. We can supply an argument like so:


###

class Flower(models.Model):
  petal_color = models.CharField(max_length=20)
  petal_number = models.IntegerField(default=0)

###


These arguments give us finer control over what data we want to include in our database. 

For .CharField() we used max_length to limit the number of acceptable characters to 20. We can even set default values, like for petal_number, 
we set default=0 meaning if we didn’t provide a value for petal_number the value is automatically 0.


code example: (inside of models.py)

###

from django.db import models

class Owner(models.Model):
  # Delete pass and add the Owner fields
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)
  phone = models.CharField(max_length=30)

class Patient(models.Model):
  # Delete pass and add the Patient fields
  breed = models.CharField(max_length=200)
  pet_name = models.CharField(max_length=200)
  age = models.IntegerField(default=0)

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

PRIMARY KEY, FOREIGN KEY, AND RELATIONSHIPS


Later on, we’ll use these models to create instances (specific model objects) in our database. 
With a Flower model, we could create instances with characteristics of flowers like a rose, a sunflower, or a daisy. 
Instances then correspond to rows, or records, in our database.


We’d also need our instances to have a unique ID to help us keep track of each one. 
These IDs are called primary keys and Django helps us automatically create these unique IDs by incrementing by 1 each time. 
For example, if our first Flower instance is rose, it would have a primary key/ID of 1. 
The second instance, sunflower, a primary key of 2 — then maybe a daisy with a primary key of 3, and so forth.


In our apps, we often create multiple models that relate to each other in some way. 
For our example Flower model, we could have a gardener tend to flowers! This means we need to create another model called Gardener:


###

class Gardener(models.Model):
  first_name = models.CharField(max_length=20)
  years_experience = models.IntegerField()

###


Now the question is how do we show this relationship between Flower and Gardener? 

Well, let’s say that a Gardener instance can tend to multiple Flower instances, but a Flower instance can only have a single Gardener. 

This means we have a One to Many relationship, one Gardener for multiple Flowers. Conversely, Flowers have a Many to One relationship with a Gardener.


To make this connection known, we need to supply Flower with a foreign key of a Gardner, i.e. the Flower instances know which Gardener instance takes care of it.


###

# Garden has a one-to-many relationship with Flower
class Gardener(models.Model):
  first_name = models.CharField(max_length=20)
  years_experience = models.IntegerField()
 
# Flower has a many-to-one relationship with Gardener
class Flower(models.Model):
  petal_color = models.CharField(max_length=10)
  petal_number = models.IntegerField()
  gardener = models.ForeignKey(Gardener, on_delete=models.CASCADE) 

###


Notice that we added the gardener field using models.ForeignKey() and with arguments. 

The first argument is Gardener because that’s the model we want this foreign key to come from. 

Then we add on_delete=models.CASCADE to let Django know to delete the Flower instance if its connected Gardener instance is deleted. 


Hypothetically, we could even supply Gardener with a foreign key as well if we wanted to link Gardener to another model, like a Garden for example! 

These foreign keys tell the database that a one-to-many relationship exists and the direction of this relationship. 

There are other types of relationships, but let’s implement a one-to-many relationship with our own models!

https://docs.djangoproject.com/en/3.1/topics/db/examples/



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FIELD TYPE OPTIONAL ARGUMENTS


We can continue to customize our models by supplying fields with options, that specify how data can be inserted into the database. 

Django provides field option documentation, which shows a huge list of these options. Let’s go over some common ones together!

https://docs.djangoproject.com/en/3.1/topics/db/models/#field-options


One common option is null that can take on a value of True or False. This null option tells the database if a field can be left intentionally void of information. 

By default, Django sets null=False. However, we can override the default and set null=True. Here’s an example:


###

class Flower(model.Model):
  petal_number = models.IntegerField(max_length=20, null=True)
  # Other fields

###


With the code above, when we create a Flower instance, we can set petal_number to null.

Another common option is blank, which is similar to null, but setting blank to True means a field doesn’t have to take anything, not even a null value. 

By default blank is False.


###

class Flower(model.Model):
  nickname = models.CharField(max_length=20, blank=True)
  # Other fields

###


Now, when we create a Flower instance, we can leave the nickname field blank.

The last one we’ll touch upon is choices which limits the input a field can accept. 

We can set choices by creating a list of tuples that contain 2 items: a key and a value. Take for example


###

class Flower(models.Model):
  COLOR_CHOICES = [
     ("R", "Red"),
     ("Y", "Yellow"),
     ("P", "Purple"),
     ("O", "Other"),
  ]
 
  color = models.CharField(max_length=1, choices=COLOR_CHOICES)
  # Other fields

###


For our Flower instance, we can specify its color with the limited choices provided — meaning our color field can only be assigned "R" (for "Red"), 

"Y" (for "Yellow"), or "P" (for "Purple"), or "O" (for "Other" from the COLOR_CHOICES list. With choices we know exactly what data we can accept from users.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MODEL METADATA

We’ve supplied our models with plenty of fields and data, but what about metadata? Let’s first define it.

Metadata is an optional entity within a model and it is anything that is not a field. 
Some helpful metadata can include how to order instances, create human-readable names, providing a database table name, and more.

https://docs.djangoproject.com/en/3.1/ref/models/options/#model-meta-options

***

Data that provide information about other data. Metadata summarizes basic information about data, making finding & working with particular instances of data easier. 
Metadata can be created manually to be more accurate, or automatically and contain more basic information

***


To add metadata to a model, we’ll need to nest another class called Meta inside the model’s class definition. Let’s use metadata to order instances as an example:

###

class Flower(models.Model):
  name = models.CharField(max_length=10)
  # All the other attributes
 
  class Meta:
    ordering = ["name"]

###


In this case, we created an attribute, ordering which takes a list of strings (["name"]) that determine the ordering. 
Later on, when we need to search for Flower instances, the database will return back a list with the list ordered by the name field. 
We can even reverse the order by adding a - in front of a string like ["-name"].


Other metadata work in a similar fashion. Let’s try adding a verbose human-readable name:

###

class TropicalFlower(models.Model):
  # Fields and Methods
 
  class Meta:
    verbose_name = "tropical flower" 

###


Without setting this metadata, our model’s name would be tropical_flower by default, here we’ve assigned the verbose name to be "tropical flower". 

While our change was subtle, we could provide even more detail to inform other developers about our model.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

NATIVE MODEL METHODS

Methods are functions defined in our model that describe the behaviors and actions of our model. 

If properties are what our models are, then methods are what our models do. For example, our flower might bloom() and grow().


In Python classes, which Django uses to create models, there are built-in methods we can override like the __str__ method. 
All this means is we are creating a method using the same name as the built-in one. This is how we, the programmer, take control, or “override”, the default behavior of the built-in version:

###

class Gardener(models.Model):
  name = models.CharField(max_length=30)
 
  def __str__(self):
    return self.name

###


Methods always require the first parameter to be self, then we can provide other optional parameters and add logic within the method body.

In the next lesson, we’ll learn how useful overriding __str__ is when we need to retrieve instances of models from our database — by default, 
if we didn’t override __str__ printing our instances would generate output that’s hard to read like:


***

<QuerySet [<Gardener:>,<Gardener:>,<Gardener:>....]

***

But with our overridden __str__ method, we’ll get more helpful information, in this case, we’re returning the Gardener instance’s name:

***

<QuerySet [<Gardener: Linnaeus>,<Gardener: Mendel>, <Gardener: Carver >....]

***


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CUSTOM MODEL METHODS

In addition to overriding native methods, we can define our own custom methods!

We can do something simple like returning a boolean:


###

class Flower(models.Model):
  has_sunlight = models.BooleanField(default=True)
  has_water = models.BooleanField(default=True)
 
  def can_grow(self):
    return self.has_sunlight and self.has_water

###


Above, we defined our custom .can_grow() method that checks if the instance’s .has_sunlight and .has_water fields are True. Notice that even for custom methods, we need to provide the first parameter as self. We can also provide additional parameters as needed.

Here’s another example that returns a string:


###

class Gardener(models.Model):
  years_experience = models.IntegerField()
 
  def identify_flower(self, flower):
    return f"I've studied flowers for {self.years_experience}. I believe this flower is {flower.name} and is found in {flower.native_env}." 

###

In this case, we’ve added a second parameter to our method, a flower instance, and returned a string. Both methods do different things but 
both help emulate real-life behaviors.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MIGRATIONS - MAKEMIGRATIONS

From when we first created our project, we’ve configured some database settings and let our project know about our app in settings.py. 
Now we need to let our database know about our models.


This step of setting the database to match the structure of the models is called migration. Remember, migrations are needed when we make changes to our models — and we’ve just made two new ones! 

Remember, migrations are needed when we make changes to our models — and we’ve just made two new ones!

Migrations documentation: https://docs.djangoproject.com/en/3.1/topics/migrations/


In Django, there are two steps necessary to make this migration happen:

1) Running python3 manage.py makemigrations -> to create a file with the instructions needed for our database to create the proper schemas.

2) Running python3 manage.py migrate -> to execute the instructions in our file to create the actual tables in our database.


We’ll first focus on makemigrations. Since we need to use manage.py to execute this step, we need to be in our root folder to execute:

###

python3 manage.py makemigrations

###


Using our hypothetical Flower and Gardener example, we should see something similar to:


***

Migrations for 'gardens':
  gardens/migrations/0001_initial.py
    - Create model Flower
    - Create model Gardener

***


We can also provide an additional argument after makemigrations and specify a chosen app’s models we want to commit. For instance, if we had two apps Garden and FlowerShop and we only wanted to commit the models for Garden, we could execute the command: python3 manage.py makemigrations garden.


The files created from this step live in the migrations folder within our app directory. Our first migration file would begin with 0001_initial.py. We can refer to our migrations using the starting numbers, in this case, it has a migration name of 0001.


It’s important that every time we need to make a change to the schema in our database we need to do this makemigrations step! Subsequent migration files will increase the number at the beginning of the file. For example, the second migration will begin with 0002_xxxxx.py and so forth.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MIGRATIONS - MIGRATE

With our migration file set up, it’s time to use the code in our file to make changes to our database.

The command to execute at the terminal would be:

###

python3 manage.py migrate

###

Like makemigrations, if our project supports multiple apps, we can pass in the particular app name to the migrate command as well. For example:

###

python3 manage.py migrate garden

###

Where garden is the name of our app. We should see some output like:

***

Operations to perform:
  Apply all migrations: gardens
Running migrations:
  Rendering model states... DONE
  Applying garden.0001_initial... OK

***

After executing the migrate command, our database is set up! Under the hood, Django is handling the SQL commands needed to make this migration happen — however, that’s beyond this lesson’s scope.


If we need to reverse a migration, Django also makes this possible by specifying the migration we want to revert back to:


###

python3 manage.py migrate <migration_name>

###

Where we replace <migration_name> with the name of the migration like 0001. Then the database’s schema reverts back to the model from our 0001 migration!

However, in some cases, migrations cannot be unapplied like if we dropped a table in a previous migration. In such cases, we’ll get an IrreversibleError. Check out Django’s documentation for more information.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

VIEWS

Views play an important role in the MTV (Model-Template-View) architectural pattern and essentially act as a link between the Model data and the Templates. A view is a function that takes in an HTTP request and returns an HTTP response.

In Django, a response can deliver webpage content in the form of HTML and templates, however, it can also respond with an image, an XML document, etc. We can handle what kind of information will be displayed on the browser for users. We’ve already touched lightly on views in the previous lessons, but now we’re going to go in-depth and explore some of its functionalities and tools!

It’s important to understand that a view describes which data you see, not how you see it. You can think of a view as the middleman between the model and the template.

The view will execute the business logic and interact with the model to carry data and delegate the information to the template which determines how information is displayed.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

VIEWS REFRESHER

At this stage, we’ve learned a lot about the ins and outs of Django. When working with frameworks like Django, there are a lot of moving pieces involved and the flow of how data is passed can be a bit confusing.

However, do not fret, some of the following topics will look familiar so let’s recap and go a little more in-depth.


There are a few steps that go into accessing a view via a URL:

1) A user visits a URL which sends a request for a resource to Django (e.g. navigating to a specific endpoint).

2) Django looks into the framework for that URL path.

3) If it finds a match and the path is linked to a particular view, its view function is called.

4) The logic in that view function will be executed, usually communicating with the model and retrieving the requested data.

5) The view then renders a template along with all the data to display it to the user.



In order to access a view via a URL, Django has its own way for URL mapping and it’s done by editing the project’s url.py file.

*** As we create functions in different applications’ views.py files, we must also make sure to import said functions in the apps’ url.py file! ***

Within the url.py file, the most important thing is the urlpatterns list which looks like the following:


###

# urls.py
 
from myapp.views import home_view
 
urlpatterns = [
  path("home/", home_view),
]

###

In the example above, a request to http://example.com/home would point to that URL pattern and make a call to the function home_view() which is found in the application’s views.py file. The logic in home_view() would be executed and send back a response to the client.

Consider the home_view() containing the following logic:

###

# views.py
 
def home_view(request):
  return render(request, "template.html")

###

Within home_view() we’re also making use of the function render(). As we saw prior, render() is a shortcut function that takes in an HttpRequest object and a template in order to display it back to the client.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CLASS BASED VIEWS -> https://docs.djangoproject.com/en/3.1/topics/class-based-views/generic-display/

We’ve explored how to write view functions in order to render templates and return them to the browser. In this exercise, we’ll look into how to use class-based views and implement generic views in order to keep our code clean and DRY. (DRY -> Dont Repeat Yourself)

https://docs.djangoproject.com/en/3.1/topics/class-based-views/generic-display/

Django provides us with base views that are inherited from the class view. A number of these existing generic view functions include built-in logic and provide utilities — better yet, we can combine these generics with our own written code!

Consider an application that keeps track of students in a classroom. We’ll make use of a model, Student, which holds the following fields:

###

# models.py
 
class Student(models.Model):
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)
  grade = models.CharField(max_length=30)

###

Let’s say we want to create a view that displays all of the students in a table. We could do this manually by writing a query to retrieve all the students and then pass the list to a template.

Alternatively, we could make use of a generic view called Listview. This view does exactly what we need and takes care of the logic in order to display multiple instances of a table in the database.

If we want to use some of these generic views we must first import them from django.views.generic at the top of our file, along with our Student model:

###

# views.py
 
from .models import Student
from django.views.generic import ListView

###

Once imported we can specify what model we’ll be using the ListView for:

###

# views.py
 
class StudentList(ListView):
  model = Student
  template_name = "schoolapp/student.html"

###

Notice how we changed the view from function to a class now — we even provided properties! These properties allow us to modify our view class to incorporate other information. 

Upon specifying the model we’re using Django will automatically try to find a template in <the_app_name>/<chosen_model_name>.html. 

Alternatively, we could explicitly tell the view which template to use by adding a template_name attribute to the view, as well as specifying the model with the model attribute. 

In this case, we specified the model as Student and explicitly set template_name as the "schoolapp/student.html" template.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CRUD THROUGH CLASS BASED VIEWS

Class-based views set up a lot of functionality automatically for us. In the previous exercise, we were able to list out (i.e. Read) instances. This time around let’s add in the rest of the CRUD functionality using generic views.

https://docs.djangoproject.com/en/3.1/topics/class-based-views/generic-display/

The same general syntax patterns exist for all 4 generic views, however, there are some slight differences. For example, if we go back to thinking about a Student model, here’s how we could add a view to create a Student instance:

###

# views.py
 
from .models import Student
from django.views.generic import ListView
from django.views.generic.edit import CreateView
 
class StudentCreate(CreateView):
  model = Student
  template_name = "schoolapp/student_create_form.html"
  fields = ["first_name", "last_name", "grade"]

###

The syntax looks very similar, but let’s go over some key differences:

* Notice that we first have also import CreateView from another module, django.views.generic.edit.

* In the new class’s name, we append Create to the model name to get StudentCreate.

* The argument is also different and is now CreateView.

* The model remains the same, we still need to set the model we want this view to reference.

* The template (template_name) is also different. That is because to create a Student instance, we’ll need to get some user input which means we should create a form               
  template!

* Speaking of input, to know what should go in the form, we have to provide a fields property. This is an array that contains a list of the model’s fields as strings.
  In this case, we’re supplying our form template will include the options to fill in information about a student’s “first_name”, “last_name”, and “grade”.

*** Note: We’ll cover more on forms later, for now, we’ll focus on setting up the views. ***

Both the UpdateView and DeleteView resemble CreateView very closely — so let’s learn how to implement both by writing them ourselves!


----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING VIEWS TO urls.py

Now that we have completed the logic to work with class-based views, we can implement them into our URLconf so that they’re accessible when navigating to specific endpoints.

https://docs.djangoproject.com/en/3.1/topics/http/urls/#overview

However, there’s a problem because Django’s URL resolver is expecting to send a request to a callable function, not a class! Therefore, class-based views have a .as_view() method, which works its magic in order to render the appropriate logic:

###

# urls.py
 
urlpatterns = [
  path("students/", views.StudentList.as_view(), name="studentlist")
]

###

In the code above, we’re making a call to .as_view() which is a class method for our generic view, StudentList. 

We’re also adding the name attribute here. 

By assigning a name, we can quickly reference this URL using its name value in our views and templates instead of the entire lengthy URL. 

Now, if we make any future changes made to the URL path, Django automatically updates the URL definitions in view methods and templates. 

Therefore, even if the URL path changes, the name remains the same and Django will know from the name what the updated URL path is. We’ll see this behavior in later lessons when we reference a URL path in templates or redirections.


Once implemented, we can access the path students/ and our template will be rendered along with the data from our database regarding all the students.

Let’s add some paths to list out instances and also write a new path that will help create instances! In the next exercise, we’ll make our list route fully functionally by adding the rest of CRUD.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

USING PRIMARY KEYS IN URLS

We just saw how we can view an entire list of models and create new models. But what if we want to access existing individual instances by updating or deleting them?

In this case, we can make use of our model’s primary key (also known as the ID). To navigate to a specific record of an instance, a primary key will be attached to our path. 

Let’s say we land on our Student list page and we’ve displayed a table of students. We click on the 10th student on the list and we’re directed to the path: student/10. In our URLconf, we can capture this primary key by using angle brackets:

###

# urls.py
 
urlpatterns = [
  # ... Other paths
  path("students/", views.StudentList.as_view(), name="studentlist"),
  path("students/<pk>", views.StudentUpdate.as_view(), name="studentupdate")
]

###

In this case, Django knows to look for the primary key (the value is replaced by the placeholder: <pk>) in our database and render that specific record.

If we navigate to students/4, Django would grab the value, 4, as the primary key and access the database in order to retrieve that record.

Notice that the other than the <pk> portion, we’re using the same syntax. 

Again, views.StudentUpdate.as_view() is the second argument — the intention is for this view to allow users to change/update specific students’ information. 

We’ve also given a name value so we can reference it in the future. This way, we’ll be able to access any student and render their information dynamically!


----------------------------------------------------------------------------------------------------------------------------------------------------------------

RENDERING A 404

We’ve seen how to make use of views and templates by delegating data and rendering different content. However, what if a user tries to navigate to a non-existing page? In that case, it would be useful to return a 404 page that tells our users that such a page doesn’t exist!

* https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404

This behavior is so common that Django even provides a built-in view to serve a 404 page! We need to import the Http404class — which is an exception class, meaning it’ll return an error.

It’s important to write out code that takes into account any potential errors. So we have to figure out what conditions might lead to a 404 error being raised and make sure we handle that exception. 

We can do this by adding a try /except statement. The try block lets us test a block of code for errors and if an error is found, the except block will be executed. For example:

###

# views.py

from django.http import Http404
 
def product_detail_view(request, id):
  try:
    obj = Products.objects.get(pk=id)
  except Products.DoesNotExist:
    raise Http404()
 
  return render(request, "products/detail.html", {"object": obj})

###

In the example above we’re looking for a specific product by id within the try block. 

If we’re unable to find the product, the except block is executed. The except block is using the DoesNotExist exception which is raised when an object is not found for the given arguments of a query. 

However, if the object is found, we return the page that the user is looking for.

Generally, Django handles a lot of 404 errors for us, but it’s good to know how to implement logic when the need arises!


----------------------------------------------------------------------------------------------------------------------------------------------------------------

UPDATING URLS IN TEMPLATES

When writing out paths in our URLConf, we looked into how to add a class-based view to be used in our paths. Consider the following piece of code:

###

# urls.py

urlpatterns = [
  path("books/", views.BookList.as_view(), name="booklist"),
  path("books/update/<pk>", views.BookUpdate.as_view(), name="bookupdate")
]

###


In the example above, we have a class-based view called BookList with the name attribute: "booklist". 

When using class-based views, Django is smart enough to look into our template/ folder for an HTML file of the snake-case version of the same name (i.e book_list.html instead of BookList.html). 

We know that this template is given information from the view, but how do we access this information?

Within our template, we’ll be able to retrieve all of the records in our database through the BookList class:

###

<!-- /templates/book_list.html -->
 
{% for book in book_list %}
<tr>
  <td>{{ book.title }} </td>
  <td>{{ book.author }} </td>
</tr>
{% endfor %}

###

In the example above, we’re looping over all our book objects in our database, and by using interpolation we can access attributes from each book such as author and title.

We also looked in a previous exercise how we can make use of the primary key in dynamic URLs. 

Let’s assume we want to have a link attached to each book in order to delete it from the list and our database. 

In this case, we can make use of the name attribute from our book update path.

###

<!-- /templates/book_list.html -->
 
{% for book in book_list %}
<tr>
  <td>{{ book.title }} </td>
  <td>{{ book.author }} </td>
  <td><a href="{% url 'bookupdate' book.id %}"><button>Update</button></a></td>
</tr>
{% endfor %}

###

Notice the <a> element is using Python’s template for the href attribute. 

In this case, we’re adding the value used for the name attribute in our URLConf: bookupdate. 

Moreover, we’re able to specify which book we want to update by accessing its id attribute.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

VIEWS REVIEW

Way to go! We’ve explored tools and built-in functionalities that Django provides when working with views. So far we’ve learned how to:

* Create view functions within the appropriate views.py file:

###

def home_view(request):
  name = "Tom"
  text = f"<h1>My name is {name}</h1>"
  return HttpResponse(text)

###


* Explored how to use class-based views:

###

class OwnerList(Listview):
  model = Owner

###


* Attach the view function to a route urls.py file:

###

urlpatterns = [
  path("catalogue/", views.Catalogue.as_view(), name="catalogue"),
]

###


* How to access data rendered into a template:

###

<!-- /templates/book_list.html -->
 
{% for book in book_list %}
<tr>
  <td>{{ book.title }} </td>
  <td>{{ book.author }} </td>
</tr>

###


* Make use of Django’s default 404 page with Http404.

* Used dynamic URLs in templates and made use of specific views.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORMS

WHAT ARE FORMS?

When working in most application, user information is gathered using forms. Forms are mostly different input fields asking unique questions. Data gathered from forms is usually used later in the backend of the application.

In Django, these forms look and act generally the same as normal HTML forms. The largest difference between Django forms and HTML forms is that Django uses a model based system to handle the data. More information can be found in MDN’s HTML forms documentation.

https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form

When creating forms in Django, we have a number of different options available in regards to building the form. In this lesson, we’ll go over some of these methods. Including one that allows Django to build the form for us, reducing the amount of HTML we have to write ourselves.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORMS -> AN OVERVIEW OF HTML FORMS

When a form is created in any HTML document, the <form> element is used to tell the application where the user input will come from. This <form> element has two main attributes, action and method.

action is used to tell the application what script to run when the form is submitted. Most forms need an action attribute, but we don’t need it since Django handles the form submission for us.

method is used to tell the application where to submit the form data. For Django, this attribute is optional and has two possible values, "POST" and "GET". "POST" requests will send information to the server, while "GET" requests will retrieve information. We’ll be using "POST" for form submission.

Inside of the <form> can be a number of different elements. The two we’ll go over right now are the <input> and <label> elements. The <label> element is used to add a label to the <input> element. And the <input> element is where the user will input data for the form.

The <input> element has a number of optional attributes. Some of those being the id and name attributes. The name attribute is used to help us grab the data from the form in our Django application. The id attribute is used for identifying and referencing specific HTML elements. This is usually used later for the for attribute value in a <label>.

An important attribute that is used with the <input> element is the type attribute. This is used to tell the HTML document what data types to accept for input. For instance, if we use the type "email", the form will not submit unless an email is typed into the input field.

Once all the necessary input elements are added to the form, one more <input> element is needed that is of type "submit". This will create a button that lets the user send their data to the application once all of the fields are filled out.

There’s a lot more that we can explore for HTML forms, but we’ll see later on how Django takes care of some of this work for us.

https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form


* THE FORMS ARE CREATED INSIDE THE TEMPLATE FOLDER AS .HTML


----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORMS -> FORM SECURITY

When building any online form, proper defenses need to be made to protect the application from any malicious users. This is because any form is susceptible to attacks including Cross Site Request Forgery attacks, or CSRF attacks. 

These attacks happen when a user uses another user’s credentials without their knowledge and executes malicious actions.

Django has a built in method for defending against CSRF attacks by including a CSRF token. The CSRF token protects the application and the user by adding a secret token inside of the "POST" methods in the forms each time the form is rendered. 

The CSRF token ensures that only the proper user is using the proper credentials.

The best way to add this token is to add a tag to the template inside of the <form> element:

###

<form>
  {% csrf_token %}
  ...
</form>

###

This token adds all the necessary security to help defend from possible CSRF attacks and is conventionally placed at the beginning of the form.

Form validation is also necessary to help defend out applications from possible attacks that use incorrect data types to cause problems, e.g. SQL attacks. This validation can include ensuring only specific data types are being submitted to protect our database.

Form validation is usually done in views.py in Django, and consists of an if statement before assigning data from the form to the database:

###

if form.is_valid():
  form = form.save()

###

Notice how Django makes it easy to secure our application!

https://docs.djangoproject.com/en/3.1/ref/csrf/

** WE NEED TO ADD THE CSRF TOKEN TO THE FORM AND TO VIEWS.PY THE FOLLOWING CODE:

###

if form.is_valid():
  form = form.save()

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORMS -> SUBMITTING A FORM

In Django, we’ll be using the "POST" method when the form is submitted, which means all of the data from the forms will be sent to the POST method in views.py.

Before we go into accessing the POST data, we need to understand that the logic is stored in the same function in views.py that renders the template. 

Therefore, to differentiate how the view function should treat a POST request vs rendering the usual form, we use an if statement. This if statement checks that the request method is "POST". Here’s an example for how to structure our view function that handles the rendering logic:

###

#views.py

from .models import Model_Name
 
def renderTemplate(request):
  if request.method == "POST":
    test_model = Model_Name()
    test_model.field = request.POST["field_name"]
    test_model.save()
  return render(request, "template_with_form.html")

###

The first thing that needs to be done is to check if the request.method is equal to "POST". When the method is "POST", it means that the form was submitted which means that we can grab all the data and use it to create a new model instance. Notice our test_model is a new Model_Name(). 

We then assign the test_model.field a value of request.POST["field_name"]. This is because in our form, we had an input field with a name set to "field_name". 

The request.POST["field_name"] syntax shows that request is treated like a dictionary with a "field_name" property. Once all of the data from request.POST is added to the model, we can save the model and render the form again.

If our conditional isn’t met, it usually means that the form is being rendered for the first time, so we can skip the instance creation and just render the form as normal.

Aside from re-rendering the template, we could also redirect to a new template! We’ll discuss redirecting in more detail later.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORMS -> GENERICS IN DJANGO: FORMS.PY

Django can also help streamline the form creation process for us! We first need to create a file called forms.py which houses the general structure for any form we want in the application. forms.py should be created in the base directory of the application. So for our program, the path should look: vetoffice/forms.py

Django forms are used with built-in generic classes to help build the forms in the template. The code below will show a basic forms.py setup:

###

#forms.py

from django import forms
from .models import User
 
class TestForm(forms.ModelForm):
  class Meta:
    model = User
    fields = ("username")

###

The first thing that needs to be done in forms.py is that we need to import forms from django and import any model we’ll be using from .models. Then we can start constructing separate classes for each form we want to build. In this example, we created a new class called TestForm. TestForm takes in one parameter called forms.ModelForm which is used to help build these forms in the template.

Inside of the TestForm class is class Meta. This inner Meta class is used to let the application know what is inside of the parent class. Notice that we have two properties in the Meta class:

* model which tells the app what model we’ll be using

	* In the example, we’re using the User model

* fields which can be a tuple or list that informs the app what fields to use

	* In the example, we’re using one field, "username"

If we wanted to include every field of a model, instead of writing it all out inside of the fields list, we could include one string that says '__all__' to indicate that we want every field to be used.

https://docs.djangoproject.com/en/3.1/ref/class-based-views/generic-display/


----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORMS -> GENERICS IN DJANGO: VIEWS.PY

Now that we have the form made in forms.py, we can wire up our views.py classes to render our templates. Remember we’ll need to import both our form and our generic views:

###

#views.py

from .forms import TestForm
from django.views.generic.edit import CreateView

###

Recall that we had to create a class for TestForm in views.py. This class is usually named after the form, followed by the type of view being created. For instance, with our TestForm, we would make a new class that’s called TestFormCreate that takes in CreateView. A sample of this class is below.

###

#views.py

class TestFormCreate(CreateView):
  model = TestModel
  template_name = "appName/form_template.html"
  form_class = TestForm

###

This class has three properties as seen above, those being the model, the template_name, and the form_class. The model is assigned the model we want to use. 

The template_name is the template file that we want the form to be used in. 

And the form_class is going to be the class that we created in forms.py. The form_class will also tell Django to use this form within the template when building the form for us.












































