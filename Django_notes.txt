Django Notes

path: /g/My Drive/python/tms

----------------------------------------------------------------------------------------------------------------------------------------------------------------

HTTP -> Hypertext Transfer Protocol and is used to structure requests and responses over the internet

The transfer of resources happens using TCP (Transmission Control Protocol).

URL -> Uniform Resource Locator

Django comes with an admin panel, a user authentication system, a database, and something called object-relational mapper (ORM) 
that helps a web application interact with a database. These are some of the “batteries” included in Django to help build projects 
faster without having to worry about which tools to use.


The Django project describes itself as an MTV framework, using Models, Templates and Views.

* The model portion deals with data and databases, it can retrieve, store, and change data in a database.

* The template determines how the data looks on a web page.

* The view describes the data to be presented, and passes this information to the template.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

STARTING A DJANGO PROJECT

* django-admin <command> [options] ->  Django provides us with django-admin, a command-line utility that helps us with a variety of administrative tasks.

* django-admin help -> Running django-admin help will provide a list of possible commands.

* django-admin startproject <projectname> -> A Django project can be easily created with the startproject command. It takes a couple of 
  options– the name of the project and optionally the directory for our project.


Django will then create a directory for the project, or the project root folder.

* Inside the project root folder is a Python file, manage.py, that contains a collection of useful functions used to administer the project. This file 
  performs the same actions as django-admin but is set specifically to the project.

* Alongside the manage.py is another directory with the same name as the project. This folder is treated as a Python package because of the presence
  of __init__.py, and inside this directory contains important settings and configuration files for the project.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONFIGURING DJANGO SETTINGS

## Important for us are settings.py and urls.py ##

Since the project comes pre-configured, we can start a server to test that the project works. 

A development server can be started by using manage.py and providing the runserver command. 

This command must be run in the root directory, the same directory where manage.py is located. 

By default, Django will start a development server with port 8000, but an alternate port can be provided as an option.


* python3 manage.py runserver <port_number>


The Django development server will hot-reload as changes are made to the project, so we don’t have to keep restarting the server as we develop. 

* The server will keep running until we stop it with the ctrl + c.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MIGRATING THE DATABASE 

A migration is a pending database change. As we saw in settings.py, by default, Django will have some apps installed. 

Some of these default apps, for example, the admin interface, use the database and the migrations must be applied to the SQLite database.


* Whenever we make changes to the model of the database, we must apply the changes by running python3 manage.py migrate


By applying our migration, we have access to the admin app! The admin app comes pre-installed and can be navigated to since it has its URL 
provided in urls.py we saw earlier. 

At the moment there aren’t any admin users but we can still visit localhost/admin to see the admin login page.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

DJANGO APPS

A Django app is a submodule to a project, that contains the code for a specific feature.

In the submodule, we’ll find things like: a models.py file, a migration directory, and other files and directories related to the application.

A Django app can be created by running the startapp command in the project root directory, the directory with manage.py, and providing the name 
of the app as an additional option.

* python3 manage.py startapp myapp

In order for Django to be aware of the app’s existence, it needs to be added to the list of INSTALLED_APPS in the project’s settings.py file.

INSTALLED_APPS = [
  "myapp.apps.MyappConfig"
]

AFTER CREATING AN APP YOU NEED TO ADD IT TO THE INSTALLED_APP LIST


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A VIEW FOR AN APP

Views are the information brokers in a Django application that decides what data gets delivered to a template and displayed.

*  A view is a class or function that processes a request and sends a response back.

The view function may:

1) Check to see if the customer is logged in

2) Request their profile information from a database

3) Format the information in a template

4) Send back the profile page as an HTML file for the customer to view in their browser


In Django, requests, and responses are handled as HttpRequest and HttpResponse objects from a module called django.http.


When a page is requested:
1) Django creates an HttpRequest object that contains information about the request

2)Django loads the appropriate view, passing the HttpRequest as the first argument to the view function


Each view function is responsible for returning an HttpResponse object. The HttpResponse response object can be the HTML 
contents of a web page, a redirect, an error, an XML document, an image, or just about anything that can display on a web page.


A simple view function would look like this:

def index(request):
	return HttpResponse("this is the response!")


THE FUNCTIONS MUST BE WRITTEN INSIDE views.py code


----------------------------------------------------------------------------------------------------------------------------------------------------------------

USING A VIEW TO SEND AN HTML PAGE 


We can use Django to render an HTML page when a view function is called. 

Django will look in each app folder inside INSTALLED_APPS for directories named templates. 

* That is to place our HTML pages inside a directory that has the same name as your app within the templates/ directory.


The resulting folder structure will look like this:

myapp/
	templates/
		myapp/
			mytemplate.html


View to send an HTML page:

###

from django.template import loader

def home():
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render())

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A DJANGO TEMPLATE


To place content generated from Django inside the HTML file, we need to turn our static HTML file into a template.


In the context of a web framework, templates are pages created with special markup that allows for backend data and 
commands to modify the contents of a page.


Django employs a special syntax called Django Templating Language to distinguish itself from HTML, CSS, and JavaScript.


That syntax in many template languages uses curly braces, sometimes referred to as handlebars, as a placeholder for data 
that is passed by Django.


In HTML, we use curly braces like this: inside the app template

<h1>Hello, {{name}}</h1>


When we call the view to render the template, we can use something called a context to tell Django what to replace in the template


The relationships in the context are referred to as a name/value pair. By default, a context is an empty dictionary.


* context = {"name": "Junior"}


We then pass the context as an argument in the render function inside of view.py.


###

from django.http import HttpResponse
from django.template import loader

def home(request):
  context = {"name": "Junior"}
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render(context))

###

This would return a webpage that says “Hello, Junior” inside an <h1> tag.


It’s quite common in Django to load templates, fill their context, and return an HttpResponse object with their rendered template. 


Django provides a shortcut for this pattern called the render() function! The render() function will do the work of loading the
template and provide the contexts when they are passed as arguments.


###

from django.shortcuts import render
 
def home(request):
  context = {"name": "Junior"}
  return render(request, "app/home.html", context)

###


The render() function takes the request object as its first argument, a template name as its second argument, and a dictionary 
as an optional third argument that passes the context variables to the template.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

WIRING UP A VIEW

On the internet, every page needs its own URL because each URL displays unique information.

In Django, we can use something called a URLconf, for URL configuration.

An app’s URLconf is located in a file named urls.py inside the app’s directory.

At the top of the urls.py we import the path object from django.urls and we import the view functions from views.py and 
add routes that direct to each of our view functions.


urls.py will look like this:

###

from django.urls import path
from . import views
 
urlpatterns = [
  path('', views.home),
  path('profile/', views.profile, name="profile")  
]

###


After the import statements is a list of patterns called urlpatterns, which contain the routes to each view function.


Each route is provided as a path() object that has three arguments: the URL route as a string, the name of the function 
of the view, and an optional name used to refer to the view.


To make Django aware of the app’s URLconf, it must be included in the project’s URLconf, also called urls.py.


The default urls.py folder for a project looks like this:

###

from django.contrib import admin
from django.urls import path
 
urlpatterns = [
  path("admin/", admin.site.urls),
]

###


To include the app’s URLconf we import the include path from django.urls and add a path()to the urlpatterns.

###

from django.contrib import admin
from django.urls import include, path
 
urlpatterns = [
  path("admin/", admin.site.urls),
  path("", include("myapp.urls")),
]

###


With both URLconfs set up, we can properly view our routes for the application: myapp in a web browser.


*** You have to create a urls.py file inside the app forlder and also create the urls paths inside the urls.py file from the project directory



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORTUNE TELLER - PROJECT

1) start new project 

* django-admin startproject fortuneteller



2) change directory to the fortuneteller project just created and run the migrate command

* cd fortuneteller

* python3 manage.py migrate



3) run the server to check for errors

* python3 manage.py runserver 0.0.0.0:4001 

to stop the development server -> ctrl + c



4) create a new app inside the project: "randomfortune"

* python3 manage.py startapp randomfortune



5) add the new app <randomfortune> to the list of installed apps for our Django project to be aware of it.

inside of settings.py (inside the project folder): find the list named INSTALLED_APPS and add the config file for randomfortune
by inlcuiding:

"randomfortune.apps.RandomfortuneConfig" to the list.


6) create a template: 

First, we will create the template directories to namespace the template. 

Inside the project app directory, randomfortune/, create a folder named, templates. 
Next, within the newly created, templates/, create a folder named randomfortune to namespace our template file.

crate the file fortune.html which contains the template html code. 

now we need to create the view functions and the URLconfig to watch it on the web app.


7) Create a view function.


To send fortune.html to our client, we’ll write a view function and send it when the page is requested.

Inside the randomfortune app, open views.py. Define a new function named fortune() that takes a single parameter, request.

In fortune(), return the render function with two arguments, the request and the path to fortune.html 
as a string, "randomfortune/fortune.html".

###

from django.shortcuts import render

# Create your views here.
def fortune(requst):
  return render(request, "randomfortune/fortune.html")

###


8) Wire up view.

Our fortune() view function sends back fortune.html when called. We’ll need to tell Django which URL we want to direct to this function.

First, create the URLconf for the randomfortune app by creating a file named urls.py inside the app directory.



Inside urls.py, we’ll need to import a couple of things to call the view function when the URL is requested.

At the top of urls.py import:

-> path module from django.urls

-> the functions from views.py.


###

from django.urls import path
from django.urls import views

urlpatterns = [
  path("", views.fortune)
]

###


9) Now that we have our app’s URLconfig setup, we will have to import it in the project’s URLconfig for the URLs to be picked 
up by the Django project.


We’ll have to import the include module to include the URL configuration file.


Inside fortuneteller/fortuneteller, import the include module from django.urls.

In the existing urlpatterns list, add another path() with the arguments:

"" to reference the home page

include() with randomfortune‘s URLs as a string.

###

from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("", include("randomfortune.urls"))
]

###


10) Sending a Context to the Template


Create a list of fortunes named fortuneList inside our app’s views.py file. Define it outside of the fortune() function.

To select a random fortune from the list we’ll use a built-in Python function, random.choice().

###

def fortune(request):
  fortune = random.choice(fortuneList)
  context = {"fortune", fortune}
  return render(request, "randomfortune/fortune.html", context)

###


Great! We now have a random fortune stored in fortune. To send it to the HTML template, we’ll create 
a context variable to send with the template.



11) Render context inside template


The last step to render the fortune in the template is to use the Django template language to replace 
the placeholder text. Inside fortune.html, between the <p></p> tags, replace the text with {{ fortune }}.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

TEMPLATES
















