Django Notes

path: /g/My Drive/python/tms

----------------------------------------------------------------------------------------------------------------------------------------------------------------

HTTP -> Hypertext Transfer Protocol and is used to structure requests and responses over the internet

The transfer of resources happens using TCP (Transmission Control Protocol).

URL -> Uniform Resource Locator

Django comes with an admin panel, a user authentication system, a database, and something called object-relational mapper (ORM) 
that helps a web application interact with a database. These are some of the “batteries” included in Django to help build projects 
faster without having to worry about which tools to use.


The Django project describes itself as an MTV framework, using Models, Templates and Views.

* The model portion deals with data and databases, it can retrieve, store, and change data in a database.

* The template determines how the data looks on a web page.

* The view describes the data to be presented, and passes this information to the template.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

STARTING A DJANGO PROJECT

* django-admin <command> [options] ->  Django provides us with django-admin, a command-line utility that helps us with a variety of administrative tasks.

* django-admin help -> Running django-admin help will provide a list of possible commands.

* django-admin startproject <projectname> -> A Django project can be easily created with the startproject command. It takes a couple of 
  options– the name of the project and optionally the directory for our project.


Django will then create a directory for the project, or the project root folder.

* Inside the project root folder is a Python file, manage.py, that contains a collection of useful functions used to administer the project. This file 
  performs the same actions as django-admin but is set specifically to the project.

* Alongside the manage.py is another directory with the same name as the project. This folder is treated as a Python package because of the presence
  of __init__.py, and inside this directory contains important settings and configuration files for the project.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONFIGURING DJANGO SETTINGS

## Important for us are settings.py and urls.py ##

Since the project comes pre-configured, we can start a server to test that the project works. 

A development server can be started by using manage.py and providing the runserver command. 

This command must be run in the root directory, the same directory where manage.py is located. 

By default, Django will start a development server with port 8000, but an alternate port can be provided as an option.


* python3 manage.py runserver <port_number>


The Django development server will hot-reload as changes are made to the project, so we don’t have to keep restarting the server as we develop. 

* The server will keep running until we stop it with the ctrl + c.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MIGRATING THE DATABASE 

A migration is a pending database change. As we saw in settings.py, by default, Django will have some apps installed. 

Some of these default apps, for example, the admin interface, use the database and the migrations must be applied to the SQLite database.


* Whenever we make changes to the model of the database, we must apply the changes by running python3 manage.py migrate


By applying our migration, we have access to the admin app! The admin app comes pre-installed and can be navigated to since it has its URL 
provided in urls.py we saw earlier. 

At the moment there aren’t any admin users but we can still visit localhost/admin to see the admin login page.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

DJANGO APPS

A Django app is a submodule to a project, that contains the code for a specific feature.

In the submodule, we’ll find things like: a models.py file, a migration directory, and other files and directories related to the application.

A Django app can be created by running the startapp command in the project root directory, the directory with manage.py, and providing the name 
of the app as an additional option.

* python3 manage.py startapp myapp

In order for Django to be aware of the app’s existence, it needs to be added to the list of INSTALLED_APPS in the project’s settings.py file.

INSTALLED_APPS = [
  "myapp.apps.MyappConfig"
]

AFTER CREATING AN APP YOU NEED TO ADD IT TO THE INSTALLED_APP LIST


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A VIEW FOR AN APP

Views are the information brokers in a Django application that decides what data gets delivered to a template and displayed.

*  A view is a class or function that processes a request and sends a response back.

The view function may:

1) Check to see if the customer is logged in

2) Request their profile information from a database

3) Format the information in a template

4) Send back the profile page as an HTML file for the customer to view in their browser


In Django, requests, and responses are handled as HttpRequest and HttpResponse objects from a module called django.http.


When a page is requested:
1) Django creates an HttpRequest object that contains information about the request

2)Django loads the appropriate view, passing the HttpRequest as the first argument to the view function


Each view function is responsible for returning an HttpResponse object. The HttpResponse response object can be the HTML 
contents of a web page, a redirect, an error, an XML document, an image, or just about anything that can display on a web page.


A simple view function would look like this:

def index(request):
	return HttpResponse("this is the response!")


THE FUNCTIONS MUST BE WRITTEN INSIDE views.py code


----------------------------------------------------------------------------------------------------------------------------------------------------------------

USING A VIEW TO SEND AN HTML PAGE 


We can use Django to render an HTML page when a view function is called. 

Django will look in each app folder inside INSTALLED_APPS for directories named templates. 

* That is to place our HTML pages inside a directory that has the same name as your app within the templates/ directory.


The resulting folder structure will look like this:

projectname/
 |-- appname/
     |-- templates/
          |-- appname/
              |-- first_template.html



View to send an HTML page:

###

from django.template import loader

def home():
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render())

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A DJANGO TEMPLATE


To place content generated from Django inside the HTML file, we need to turn our static HTML file into a template.


In the context of a web framework, templates are pages created with special markup that allows for backend data and 
commands to modify the contents of a page.


Django employs a special syntax called Django Templating Language to distinguish itself from HTML, CSS, and JavaScript.


That syntax in many template languages uses curly braces, sometimes referred to as handlebars, as a placeholder for data 
that is passed by Django.


In HTML, we use curly braces like this: inside the app template

<h1>Hello, {{name}}</h1>


When we call the view to render the template, we can use something called a context to tell Django what to replace in the template


The relationships in the context are referred to as a name/value pair. By default, a context is an empty dictionary.


* context = {"name": "Junior"}


We then pass the context as an argument in the render function inside of view.py.


###

from django.http import HttpResponse
from django.template import loader

def home(request):
  context = {"name": "Junior"}
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render(context))

###

This would return a webpage that says “Hello, Junior” inside an <h1> tag.


It’s quite common in Django to load templates, fill their context, and return an HttpResponse object with their rendered template. 


Django provides a shortcut for this pattern called the render() function! The render() function will do the work of loading the
template and provide the contexts when they are passed as arguments.


###

from django.shortcuts import render
 
def home(request):
  context = {"name": "Junior"}
  return render(request, "app/home.html", context)

###


The render() function takes the request object as its first argument, a template name as its second argument, and a dictionary 
as an optional third argument that passes the context variables to the template.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

WIRING UP A VIEW

On the internet, every page needs its own URL because each URL displays unique information.

In Django, we can use something called a URLconf, for URL configuration.

An app’s URLconf is located in a file named urls.py inside the app’s directory.

At the top of the urls.py we import the path object from django.urls and we import the view functions from views.py and 
add routes that direct to each of our view functions.


urls.py will look like this:

###

from django.urls import path
from . import views
 
urlpatterns = [
  path('', views.home),
  path('profile/', views.profile, name="profile")  
]

###


After the import statements is a list of patterns called urlpatterns, which contain the routes to each view function.


Each route is provided as a path() object that has three arguments: the URL route as a string, the name of the function 
of the view, and an optional name used to refer to the view.


To make Django aware of the app’s URLconf, it must be included in the project’s URLconf, also called urls.py.


The default urls.py folder for a project looks like this:

###

from django.contrib import admin
from django.urls import path
 
urlpatterns = [
  path("admin/", admin.site.urls),
]

###


To include the app’s URLconf we import the include path from django.urls and add a path()to the urlpatterns.

###

from django.contrib import admin
from django.urls import include, path
 
urlpatterns = [
  path("admin/", admin.site.urls),
  path("", include("myapp.urls")),
]

###


With both URLconfs set up, we can properly view our routes for the application: myapp in a web browser.


*** You have to create a urls.py file inside the app forlder and also create the urls paths inside the urls.py file from the project directory



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORTUNE TELLER - PROJECT

1) start new project 

* django-admin startproject fortuneteller



2) change directory to the fortuneteller project just created and run the migrate command

* cd fortuneteller

* python3 manage.py migrate



3) run the server to check for errors

* python3 manage.py runserver 0.0.0.0:4001 

to stop the development server -> ctrl + c



4) create a new app inside the project: "randomfortune"

* python3 manage.py startapp randomfortune



5) add the new app <randomfortune> to the list of installed apps for our Django project to be aware of it.

inside of settings.py (inside the project folder): find the list named INSTALLED_APPS and add the config file for randomfortune
by inlcuiding:

"randomfortune.apps.RandomfortuneConfig" to the list.


6) create a template: 

First, we will create the template directories to namespace the template. 

Inside the project app directory, randomfortune/, create a folder named, templates. 
Next, within the newly created, templates/, create a folder named randomfortune to namespace our template file.

crate the file fortune.html which contains the template html code. 

now we need to create the view functions and the URLconfig to watch it on the web app.


7) Create a view function.


To send fortune.html to our client, we’ll write a view function and send it when the page is requested.

Inside the randomfortune app, open views.py. Define a new function named fortune() that takes a single parameter, request.

In fortune(), return the render function with two arguments, the request and the path to fortune.html 
as a string, "randomfortune/fortune.html".

###

from django.shortcuts import render

# Create your views here.
def fortune(requst):
  return render(request, "randomfortune/fortune.html")

###


8) Wire up view.

Our fortune() view function sends back fortune.html when called. We’ll need to tell Django which URL we want to direct to this function.

First, create the URLconf for the randomfortune app by creating a file named urls.py inside the app directory.



Inside urls.py, we’ll need to import a couple of things to call the view function when the URL is requested.

At the top of urls.py import:

-> path module from django.urls

-> the functions from views.py.


###

from django.urls import path
from django.urls import views

urlpatterns = [
  path("", views.fortune)
]

###


9) Now that we have our app’s URLconfig setup, we will have to import it in the project’s URLconfig for the URLs to be picked 
up by the Django project.


We’ll have to import the include module to include the URL configuration file.


Inside fortuneteller/fortuneteller, import the include module from django.urls.

In the existing urlpatterns list, add another path() with the arguments:

"" to reference the home page

include() with randomfortune‘s URLs as a string.

###

from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("", include("randomfortune.urls"))
]

###


10) Sending a Context to the Template


Create a list of fortunes named fortuneList inside our app’s views.py file. Define it outside of the fortune() function.

To select a random fortune from the list we’ll use a built-in Python function, random.choice().

###

def fortune(request):
  fortune = random.choice(fortuneList)
  context = {"fortune", fortune}
  return render(request, "randomfortune/fortune.html", context)

###


Great! We now have a random fortune stored in fortune. To send it to the HTML template, we’ll create 
a context variable to send with the template.



11) Render context inside template


The last step to render the fortune in the template is to use the Django template language to replace 
the placeholder text. Inside fortune.html, between the <p></p> tags, replace the text with {{ fortune }}.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

TEMPLATES

The Convenience of templates:

Django uses templates to display information to users. In conventional web development, web pages are written with HTML.

Rather, Django gives us Django Template Language (DTL) which lets us inject variables, logic, and control flow inside of our HTML - supercharging 
our HTML files to do so much more than provide static content.

Django Template Language (DTL) -> https://docs.djangoproject.com/en/3.1/ref/templates/language/

In Django, templates are going to be the user facing content. However, Django templates usually have added 
Django Template Language, or DTL, modifications.

In order to create templates, they have to be stored in the application in a folder called templates/. 

Another folder needs to be created inside of this templates/ folder that uses the same name of the application. All of the templates will 
go into this folder named after the application. 



----------------------------------------------------------------------------------------------------------------------------------------------------------------

REVISITING OUR FIRST TEMPLATE

The first template usually made is the homepage of the application. 

Templates can be plain HTML files and are stored inside of appname/templates/appname/.

When any template is referenced later, it will be done by calling appname/template_name.html. 

Once the template is made, some of the code in views.py will have to be modified in order to render the template.

Rendering the template is the Django application taking the template and displaying it as a normal HTML page in a web browser.

Inside of views.py, we need functions, or classes, that tell the template what information to include.

Just as a refresher, the final method in views.py should look like the one below:

###

def homepage(request):
  return render(request, "app_name/sample_template.html")

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A BASE TEMPLATE

An basic navigation bar looks like the following:

###

<div class="topnav" id="pageTopNav">
  <a href="#home" class="active">Home</a>
  <a href="#contact">Contact</a>
</div>

###


A base template is created the same way as a normal template, starting with an HTML file. 

By convention, the base template is usually called something like base.html or base_template.html.

Once the common elements have been moved to base.html, we can start talking about adding page-specific content.

Since the base.html will be used across several templates, we need to tell the application where we want our page-specific content to go.

To do this, we add tags to the body of the base template. Tags are used to help extend the base template to other templates.

tags are created using the {% and %} symbols.

Inside of these tags, we’ll be adding block content, and later another tag with the content endblock.

This creates a block that we can add code to in other templates. This block gives us the ability to later insert content 
that is specific to individual pages. It should look like this:

###

{% block content %}
 
{% endblock %}

###


Typically only page-specific content will go inside of these tags and is added from other templates. These blocks are usually 
left empty in the base template though. Multiple blocks can be created within the base template and then used in other templates.

base.html:

###

<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <h1>Welcome to Vet Office!</h1>
    {% block content %}

    {% endblock %}
  </body>

</html>

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

EXTENDING THE BASE TEMPLATE

We can refactor our other templates by removing the common elements.

###

{% extends "vetoffice/base.html" %}
 
{% block content %}
<p>This will go inside the body</p>
 
<p>This will also be inside the body</p>
{% endblock %}

###

----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING CSS TO THE TEMPLATES

We need a folder to store our CSS files, this folder will be in the application’s main folder and called static/. 


This folder will hold assets like pictures and CSS files. Another folder will be created inside of static/ that will be named after our application.

The full path should look like the one below:


projectname/
 |-- appname/
     |-- templates/
     |-- static/
         |-- appname/
             |-- file.css


Once a CSS file is added to static/appname, it can be referenced within our templates inside of blocks 
formed in the base.html <head> elements. 

This is because static files will not be passed down to children of the base.html template. 

The files in our static/ folder should be loaded in the <header>. 

Therefore, we’ll add another block tag, like so:


###

<!-- base.html -->
<!DOCTYPE html>
<head>
  {% block head %}
 
  {% endblock %}
</head>
...

###


Inside of the template we’ll be using, we first need to load in static files. 

This is typically done at the beginning of the file after extending from base.html.

This will let us access all of our static files later. Then the block created from base.html can be added to the document.

This is the block where the CSS will be loaded in. This is done by loading a CSS file as normal, 
except setting the href to a tag that says {% static 'appname/file.css' %}. 

It should look like the code below.

###

<!-- template_example.html -->
{% load static %}
 
{% block head %}
<link rel="stylesheet" href="{% static 'appname/file.css' %}">
{% endblock %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

VARIABLES IN TEMPLATES

DTL can do so much more for us, like grabbing variables from views.py, creating loops, if statements, 
and more! In this exercise, we’ll start with creating variables.

The syntax for evaluating variables — two symbols are needed, {{ and }}, we call these symbols variable tags. 

When we add a variable in between variable tags, Django knows that we want the value of that variable from our views.py file.

###

<p>Welcome, {{ name }}!</p>

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONDITIONALS IN TEMPLATES

Now that we have covered variables, we can start using if statements. 

These if statements help customize web pages without having to create separate templates for different instances.

An if statement in DTL is very similar to Python if statements. 

However, they consist of two necessary components and two optional components. 



The major components are:

+ An if keyword is used in every if statement and its purpose is the same as in Python.

+ An endif keyword is used to let DTL know that we are at the end of the if statement.



The two optional components are:

+ elif - which is used if we want to check more than one condition within the if statement.

+ else - which will execute whenever the if and all elifs evaluates as false. It will be the last thing 
included in an if statement before the endif.



To add an if statement to the template, we’ll need to set it up inside of tags. 

Remember, tags are the {% and %} symbols we used earlier for extending our base template to other templates.

Generally, tags are used to tell the DTL that an expression needs to be executed or evaluated. 

There is no need to use separate variable tags when accessing a variable in normal tags. 


###

{% if city.name == "New York" %}
  <p>Attractions for New York City are</p>
  ...
{% elif city.name == "Los Angeles" %}
  <p>Attractions for Los Angeles are</p>
  ...
{% else %}
  <p>We currently do not have any attractions for that city</p>
{% endif %}

###


Notice that we can use the same {% %} tags to create these conditionals within the template, and 
help tell the DTL what to render. This makes sure that only certain elements get rendered based off the conditionals detailed.

home.html example code:

###

{% extends "vetoffice/base.html" %}
{% load static %}

{% block head %}
  <link rel="stylesheet" href="{% static 'vetoffice/style.css' %}">
{% endblock %}

{% block content %}
  <p>Welcome, {{name}}!</p>
  <!-- Add your if statement below: -->
{% if pet.animal_type == "Dog" %}
  <p>The animal is a dog</p>
{% elif pet.animal_type == "Cat" %}
  <p>The animal is a cat</p>  
{% else %}
  <p>The animal is not a dog or cat</p>
{% endif %}  

{% endblock %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

LOOPS IN TEMPLATES

Loops in DTL work like regular Python for loops but still require tags.

To write a loop in DTL we’ll need to use our tags {% %} and insert the syntax for a for loop. The syntax to start a for loop requires:


1) The for keyword.

2) The name of the new variables we’ll be creating in the loop.

3) An indicator saying in

4) The list we’ll be using in the loop.


Those will all be listed out in that order, and will be followed with an {% endfor %} at the end of the loop. The loop syntax looks like:

###

{% for item in list_name %}
  <p>{{ item }}</p>
{% endfor %}

###

Inside the loop’s body, during each iteration, we can access the current key using the temporary variable key inside variable tags {{ }}. 
We’re free to manipulate the key as a variable using standard Python syntax. If our list contains dictionaries, we could even access the 
value of our dictionary if we change our loop:

###

{% for key, value in dictionary_list %}
  <p>{{ key }} : {{ value }}</p>
{% endfor %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING URLS TO TEMPLATE

When navigating between pages using HTML, we need the entire URL to be written out in a <a> element’s href attribute. With Django, rather 
than using the full URL we get a shortcut by using tags and the name of predefined paths!

Basic shortcut:

###

<a href="{% url 'path_name' %}">Sample link</a>

###


As can be seen above, the link looks very similar to a typical HTML link, except we modify the href to be set to a tag much like we did with CSS files. 
This tag is set to the type url followed by the path name as a string.


When a path requires arguments to get to, like a username, it can be added to the href after the path. We won’t go into detail regarding this, 
but it would look like this:

###

<a href="{% url 'path_name' username %}">User Profile</a>

###

In this case, arguments provide additional information to the URL to access more specific pages. Some DTL functions require arguments while they can 
be optional in other places. The URL is a good instance of where arguments are optional, but not necessary unless the path has an argument.











































