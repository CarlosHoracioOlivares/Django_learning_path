Django Notes

path: /g/My Drive/python/tms

----------------------------------------------------------------------------------------------------------------------------------------------------------------

HTTP -> Hypertext Transfer Protocol and is used to structure requests and responses over the internet

The transfer of resources happens using TCP (Transmission Control Protocol).

URL -> Uniform Resource Locator

Django comes with an admin panel, a user authentication system, a database, and something called object-relational mapper (ORM) 
that helps a web application interact with a database. These are some of the “batteries” included in Django to help build projects 
faster without having to worry about which tools to use.


The Django project describes itself as an MTV framework, using Models, Templates and Views.

* The model portion deals with data and databases, it can retrieve, store, and change data in a database.

* The template determines how the data looks on a web page.

* The view describes the data to be presented, and passes this information to the template.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

STARTING A DJANGO PROJECT

* django-admin <command> [options] ->  Django provides us with django-admin, a command-line utility that helps us with a variety of administrative tasks.

* django-admin help -> Running django-admin help will provide a list of possible commands.

* django-admin startproject <projectname> -> A Django project can be easily created with the startproject command. It takes a couple of 
  options– the name of the project and optionally the directory for our project.


Django will then create a directory for the project, or the project root folder.

* Inside the project root folder is a Python file, manage.py, that contains a collection of useful functions used to administer the project. This file 
  performs the same actions as django-admin but is set specifically to the project.

* Alongside the manage.py is another directory with the same name as the project. This folder is treated as a Python package because of the presence
  of __init__.py, and inside this directory contains important settings and configuration files for the project.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONFIGURING DJANGO SETTINGS

## Important for us are settings.py and urls.py ##

Since the project comes pre-configured, we can start a server to test that the project works. 

A development server can be started by using manage.py and providing the runserver command. 

This command must be run in the root directory, the same directory where manage.py is located. 

By default, Django will start a development server with port 8000, but an alternate port can be provided as an option.


* python3 manage.py runserver <port_number>


The Django development server will hot-reload as changes are made to the project, so we don’t have to keep restarting the server as we develop. 

* The server will keep running until we stop it with the ctrl + c.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MIGRATING THE DATABASE 

A migration is a pending database change. As we saw in settings.py, by default, Django will have some apps installed. 

Some of these default apps, for example, the admin interface, use the database and the migrations must be applied to the SQLite database.


* Whenever we make changes to the model of the database, we must apply the changes by running python3 manage.py migrate


By applying our migration, we have access to the admin app! The admin app comes pre-installed and can be navigated to since it has its URL 
provided in urls.py we saw earlier. 

At the moment there aren’t any admin users but we can still visit localhost/admin to see the admin login page.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

DJANGO APPS

A Django app is a submodule to a project, that contains the code for a specific feature.

In the submodule, we’ll find things like: a models.py file, a migration directory, and other files and directories related to the application.

A Django app can be created by running the startapp command in the project root directory, the directory with manage.py, and providing the name 
of the app as an additional option.

* python3 manage.py startapp myapp

In order for Django to be aware of the app’s existence, it needs to be added to the list of INSTALLED_APPS in the project’s settings.py file.

INSTALLED_APPS = [
  "myapp.apps.MyappConfig"
]

AFTER CREATING AN APP YOU NEED TO ADD IT TO THE INSTALLED_APP LIST


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A VIEW FOR AN APP

Views are the information brokers in a Django application that decides what data gets delivered to a template and displayed.

*  A view is a class or function that processes a request and sends a response back.

The view function may:

1) Check to see if the customer is logged in

2) Request their profile information from a database

3) Format the information in a template

4) Send back the profile page as an HTML file for the customer to view in their browser


In Django, requests, and responses are handled as HttpRequest and HttpResponse objects from a module called django.http.


When a page is requested:
1) Django creates an HttpRequest object that contains information about the request

2)Django loads the appropriate view, passing the HttpRequest as the first argument to the view function


Each view function is responsible for returning an HttpResponse object. The HttpResponse response object can be the HTML 
contents of a web page, a redirect, an error, an XML document, an image, or just about anything that can display on a web page.


A simple view function would look like this:

def index(request):
	return HttpResponse("this is the response!")


THE FUNCTIONS MUST BE WRITTEN INSIDE views.py code


----------------------------------------------------------------------------------------------------------------------------------------------------------------

USING A VIEW TO SEND AN HTML PAGE 


We can use Django to render an HTML page when a view function is called. 

Django will look in each app folder inside INSTALLED_APPS for directories named templates. 

* That is to place our HTML pages inside a directory that has the same name as your app within the templates/ directory.


The resulting folder structure will look like this:

projectname/
 |-- appname/
     |-- templates/
          |-- appname/
              |-- first_template.html



View to send an HTML page:

###

from django.template import loader

def home():
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render())

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A DJANGO TEMPLATE


To place content generated from Django inside the HTML file, we need to turn our static HTML file into a template.


In the context of a web framework, templates are pages created with special markup that allows for backend data and 
commands to modify the contents of a page.


Django employs a special syntax called Django Templating Language to distinguish itself from HTML, CSS, and JavaScript.


That syntax in many template languages uses curly braces, sometimes referred to as handlebars, as a placeholder for data 
that is passed by Django.


In HTML, we use curly braces like this: inside the app template

<h1>Hello, {{name}}</h1>


When we call the view to render the template, we can use something called a context to tell Django what to replace in the template


The relationships in the context are referred to as a name/value pair. By default, a context is an empty dictionary.


* context = {"name": "Junior"}


We then pass the context as an argument in the render function inside of view.py.


###

from django.http import HttpResponse
from django.template import loader

def home(request):
  context = {"name": "Junior"}
  template = loader.get_template("app/home.html")
  return HttpResponse(template.render(context))

###

This would return a webpage that says “Hello, Junior” inside an <h1> tag.


It’s quite common in Django to load templates, fill their context, and return an HttpResponse object with their rendered template. 


Django provides a shortcut for this pattern called the render() function! The render() function will do the work of loading the
template and provide the contexts when they are passed as arguments.


###

from django.shortcuts import render
 
def home(request):
  context = {"name": "Junior"}
  return render(request, "app/home.html", context)

###


The render() function takes the request object as its first argument, a template name as its second argument, and a dictionary 
as an optional third argument that passes the context variables to the template.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

WIRING UP A VIEW

On the internet, every page needs its own URL because each URL displays unique information.

In Django, we can use something called a URLconf, for URL configuration.

An app’s URLconf is located in a file named urls.py inside the app’s directory.

At the top of the urls.py we import the path object from django.urls and we import the view functions from views.py and 
add routes that direct to each of our view functions.


urls.py will look like this:

###

from django.urls import path
from . import views
 
urlpatterns = [
  path('', views.home),
  path('profile/', views.profile, name="profile")  
]

###


After the import statements is a list of patterns called urlpatterns, which contain the routes to each view function.


Each route is provided as a path() object that has three arguments: the URL route as a string, the name of the function 
of the view, and an optional name used to refer to the view.


To make Django aware of the app’s URLconf, it must be included in the project’s URLconf, also called urls.py.


The default urls.py folder for a project looks like this:

###

from django.contrib import admin
from django.urls import path
 
urlpatterns = [
  path("admin/", admin.site.urls),
]

###


To include the app’s URLconf we import the include path from django.urls and add a path()to the urlpatterns.

###

from django.contrib import admin
from django.urls import include, path
 
urlpatterns = [
  path("admin/", admin.site.urls),
  path("", include("myapp.urls")),
]

###


With both URLconfs set up, we can properly view our routes for the application: myapp in a web browser.


*** You have to create a urls.py file inside the app forlder and also create the urls paths inside the urls.py file from the project directory



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FORTUNE TELLER - PROJECT

1) start new project 

* django-admin startproject fortuneteller



2) change directory to the fortuneteller project just created and run the migrate command

* cd fortuneteller

* python3 manage.py migrate



3) run the server to check for errors

* python3 manage.py runserver 0.0.0.0:4001 

to stop the development server -> ctrl + c



4) create a new app inside the project: "randomfortune"

* python3 manage.py startapp randomfortune



5) add the new app <randomfortune> to the list of installed apps for our Django project to be aware of it.

inside of settings.py (inside the project folder): find the list named INSTALLED_APPS and add the config file for randomfortune
by inlcuiding:

"randomfortune.apps.RandomfortuneConfig" to the list.


6) create a template: 

First, we will create the template directories to namespace the template. 

Inside the project app directory, randomfortune/, create a folder named, templates. 
Next, within the newly created, templates/, create a folder named randomfortune to namespace our template file.

crate the file fortune.html which contains the template html code. 

now we need to create the view functions and the URLconfig to watch it on the web app.


7) Create a view function.


To send fortune.html to our client, we’ll write a view function and send it when the page is requested.

Inside the randomfortune app, open views.py. Define a new function named fortune() that takes a single parameter, request.

In fortune(), return the render function with two arguments, the request and the path to fortune.html 
as a string, "randomfortune/fortune.html".

###

from django.shortcuts import render

# Create your views here.
def fortune(requst):
  return render(request, "randomfortune/fortune.html")

###


8) Wire up view.

Our fortune() view function sends back fortune.html when called. We’ll need to tell Django which URL we want to direct to this function.

First, create the URLconf for the randomfortune app by creating a file named urls.py inside the app directory.



Inside urls.py, we’ll need to import a couple of things to call the view function when the URL is requested.

At the top of urls.py import:

-> path module from django.urls

-> the functions from views.py.


###

from django.urls import path
from django.urls import views

urlpatterns = [
  path("", views.fortune)
]

###


9) Now that we have our app’s URLconfig setup, we will have to import it in the project’s URLconfig for the URLs to be picked 
up by the Django project.


We’ll have to import the include module to include the URL configuration file.


Inside fortuneteller/fortuneteller, import the include module from django.urls.

In the existing urlpatterns list, add another path() with the arguments:

"" to reference the home page

include() with randomfortune‘s URLs as a string.

###

from django.contrib import admin
from django.urls import path
from django.urls import include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("", include("randomfortune.urls"))
]

###


10) Sending a Context to the Template


Create a list of fortunes named fortuneList inside our app’s views.py file. Define it outside of the fortune() function.

To select a random fortune from the list we’ll use a built-in Python function, random.choice().

###

def fortune(request):
  fortune = random.choice(fortuneList)
  context = {"fortune", fortune}
  return render(request, "randomfortune/fortune.html", context)

###


Great! We now have a random fortune stored in fortune. To send it to the HTML template, we’ll create 
a context variable to send with the template.



11) Render context inside template


The last step to render the fortune in the template is to use the Django template language to replace 
the placeholder text. Inside fortune.html, between the <p></p> tags, replace the text with {{ fortune }}.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

TEMPLATES

The Convenience of templates:

Django uses templates to display information to users. In conventional web development, web pages are written with HTML.

Rather, Django gives us Django Template Language (DTL) which lets us inject variables, logic, and control flow inside of our HTML - supercharging 
our HTML files to do so much more than provide static content.

Django Template Language (DTL) -> https://docs.djangoproject.com/en/3.1/ref/templates/language/

In Django, templates are going to be the user facing content. However, Django templates usually have added 
Django Template Language, or DTL, modifications.

In order to create templates, they have to be stored in the application in a folder called templates/. 

Another folder needs to be created inside of this templates/ folder that uses the same name of the application. All of the templates will 
go into this folder named after the application. 



----------------------------------------------------------------------------------------------------------------------------------------------------------------

REVISITING OUR FIRST TEMPLATE

The first template usually made is the homepage of the application. 

Templates can be plain HTML files and are stored inside of appname/templates/appname/.

When any template is referenced later, it will be done by calling appname/template_name.html. 

Once the template is made, some of the code in views.py will have to be modified in order to render the template.

Rendering the template is the Django application taking the template and displaying it as a normal HTML page in a web browser.

Inside of views.py, we need functions, or classes, that tell the template what information to include.

Just as a refresher, the final method in views.py should look like the one below:

###

def homepage(request):
  return render(request, "app_name/sample_template.html")

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATING A BASE TEMPLATE

An basic navigation bar looks like the following:

###

<div class="topnav" id="pageTopNav">
  <a href="#home" class="active">Home</a>
  <a href="#contact">Contact</a>
</div>

###


A base template is created the same way as a normal template, starting with an HTML file. 

By convention, the base template is usually called something like base.html or base_template.html.

Once the common elements have been moved to base.html, we can start talking about adding page-specific content.

Since the base.html will be used across several templates, we need to tell the application where we want our page-specific content to go.

To do this, we add tags to the body of the base template. Tags are used to help extend the base template to other templates.

tags are created using the {% and %} symbols.

Inside of these tags, we’ll be adding block content, and later another tag with the content endblock.

This creates a block that we can add code to in other templates. This block gives us the ability to later insert content 
that is specific to individual pages. It should look like this:

###

{% block content %}
 
{% endblock %}

###


Typically only page-specific content will go inside of these tags and is added from other templates. These blocks are usually 
left empty in the base template though. Multiple blocks can be created within the base template and then used in other templates.

base.html:

###

<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <h1>Welcome to Vet Office!</h1>
    {% block content %}

    {% endblock %}
  </body>

</html>

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

EXTENDING THE BASE TEMPLATE

We can refactor our other templates by removing the common elements.

###

{% extends "vetoffice/base.html" %}
 
{% block content %}
<p>This will go inside the body</p>
 
<p>This will also be inside the body</p>
{% endblock %}

###

----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING CSS TO THE TEMPLATES

We need a folder to store our CSS files, this folder will be in the application’s main folder and called static/. 


This folder will hold assets like pictures and CSS files. Another folder will be created inside of static/ that will be named after our application.

The full path should look like the one below:


projectname/
 |-- appname/
     |-- templates/
     |-- static/
         |-- appname/
             |-- file.css


Once a CSS file is added to static/appname, it can be referenced within our templates inside of blocks 
formed in the base.html <head> elements. 

This is because static files will not be passed down to children of the base.html template. 

The files in our static/ folder should be loaded in the <header>. 

Therefore, we’ll add another block tag, like so:


###

<!-- base.html -->
<!DOCTYPE html>
<head>
  {% block head %}
 
  {% endblock %}
</head>
...

###


Inside of the template we’ll be using, we first need to load in static files. 

This is typically done at the beginning of the file after extending from base.html.

This will let us access all of our static files later. Then the block created from base.html can be added to the document.

This is the block where the CSS will be loaded in. This is done by loading a CSS file as normal, 
except setting the href to a tag that says {% static 'appname/file.css' %}. 

It should look like the code below.

###

<!-- template_example.html -->
{% load static %}
 
{% block head %}
<link rel="stylesheet" href="{% static 'appname/file.css' %}">
{% endblock %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

VARIABLES IN TEMPLATES

DTL can do so much more for us, like grabbing variables from views.py, creating loops, if statements, 
and more! In this exercise, we’ll start with creating variables.

The syntax for evaluating variables — two symbols are needed, {{ and }}, we call these symbols variable tags. 

When we add a variable in between variable tags, Django knows that we want the value of that variable from our views.py file.

###

<p>Welcome, {{ name }}!</p>

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

CONDITIONALS IN TEMPLATES

Now that we have covered variables, we can start using if statements. 

These if statements help customize web pages without having to create separate templates for different instances.

An if statement in DTL is very similar to Python if statements. 

However, they consist of two necessary components and two optional components. 



The major components are:

+ An if keyword is used in every if statement and its purpose is the same as in Python.

+ An endif keyword is used to let DTL know that we are at the end of the if statement.



The two optional components are:

+ elif - which is used if we want to check more than one condition within the if statement.

+ else - which will execute whenever the if and all elifs evaluates as false. It will be the last thing 
included in an if statement before the endif.



To add an if statement to the template, we’ll need to set it up inside of tags. 

Remember, tags are the {% and %} symbols we used earlier for extending our base template to other templates.

Generally, tags are used to tell the DTL that an expression needs to be executed or evaluated. 

There is no need to use separate variable tags when accessing a variable in normal tags. 


###

{% if city.name == "New York" %}
  <p>Attractions for New York City are</p>
  ...
{% elif city.name == "Los Angeles" %}
  <p>Attractions for Los Angeles are</p>
  ...
{% else %}
  <p>We currently do not have any attractions for that city</p>
{% endif %}

###


Notice that we can use the same {% %} tags to create these conditionals within the template, and 
help tell the DTL what to render. This makes sure that only certain elements get rendered based off the conditionals detailed.

home.html example code:

###

{% extends "vetoffice/base.html" %}
{% load static %}

{% block head %}
  <link rel="stylesheet" href="{% static 'vetoffice/style.css' %}">
{% endblock %}

{% block content %}
  <p>Welcome, {{name}}!</p>
  <!-- Add your if statement below: -->
{% if pet.animal_type == "Dog" %}
  <p>The animal is a dog</p>
{% elif pet.animal_type == "Cat" %}
  <p>The animal is a cat</p>  
{% else %}
  <p>The animal is not a dog or cat</p>
{% endif %}  

{% endblock %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

LOOPS IN TEMPLATES

Loops in DTL work like regular Python for loops but still require tags.

To write a loop in DTL we’ll need to use our tags {% %} and insert the syntax for a for loop. The syntax to start a for loop requires:


1) The for keyword.

2) The name of the new variables we’ll be creating in the loop.

3) An indicator saying in

4) The list we’ll be using in the loop.


Those will all be listed out in that order, and will be followed with an {% endfor %} at the end of the loop. The loop syntax looks like:

###

{% for item in list_name %}
  <p>{{ item }}</p>
{% endfor %}

###

Inside the loop’s body, during each iteration, we can access the current key using the temporary variable key inside variable tags {{ }}. 
We’re free to manipulate the key as a variable using standard Python syntax. If our list contains dictionaries, we could even access the 
value of our dictionary if we change our loop:

###

{% for key, value in dictionary_list %}
  <p>{{ key }} : {{ value }}</p>
{% endfor %}

###



----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING URLS TO TEMPLATE


When navigating between pages using HTML, we need the entire URL to be written out in a <a> element’s href attribute. With Django, rather 
than using the full URL we get a shortcut by using tags and the name of predefined paths!

Basic shortcut:

###

<a href="{% url 'path_name' %}">Sample link</a>

###


As can be seen above, the link looks very similar to a typical HTML link, except we modify the href to be set to a tag much like we did with CSS files. 
This tag is set to the type url followed by the path name as a string.


When a path requires arguments to get to, like a username, it can be added to the href after the path. We won’t go into detail regarding this, 
but it would look like this:

###

<a href="{% url 'path_name' username %}">User Profile</a>

###

In this case, arguments provide additional information to the URL to access more specific pages. Some DTL functions require arguments while they can 
be optional in other places. The URL is a good instance of where arguments are optional, but not necessary unless the path has an argument.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FILTERS IN TEMPLATES


With Django, variables can be modified from within the template using a filter. 
Filters modify variables passed in from views.py without the use of traditional methods like JavaScript

An example filter can be seen below:

###

<p>{{ username|upper }}</p>

###


The filter is added onto a variable by using the | symbol inside of the variable tags with the variable. 
The symbol goes after the variable name, and is followed by the filter that you want to use


Some filters also require arguments, however, arguments are handled differently with filters compared to 
how we handled arguments with URL. A filter with an argument can be seen here:


###

{{ description|truncatewords_html:2 }}

###


The truncatewords_html filter requires an argument and will shorten text down to the integer supplied by our argument. 
In our case, we want to display 2 words max. Any other words in the description variable will be replaced with .... 
We were able to supply our argument after the filter name separated by a :.


Some filters also require certain data types in order to work. For instance, the time filter requires a variable 
of data type datetime.datetime.Now(), and will not work with any other data type. It is recommended to check out the 
documentation for a filter before using it to make sure you are using the proper data types and adding any necessary arguments.



----------------------------------------------------------------------------------------------------------------------------------------------------------------

REVIEW TEMPLATES

Templates are a great way to reduce the amount of HTML that needs to be written in a website by allowing us to extend templates into the rest of the website 
to reduce repeat code. The options provided to us can help us in a number of ways including:

* Common elements should go inside of a base template, and any page-specific content should be in their own templates.

* Static files have to be loaded in the template they’ll be used in, as it won’t be passed on to child templates.

* Templates can also use DTL to help display variables, loop through and display dictionaries, and create conditionals within templates to reduce the number of templates needed for an application.

* CSS files can be added to a template after adding a static/ folder to the application. Remember that inside of static/ there should be another folder named after the application.

* Variables are great for grabbing data from views.py to display in a template.
  if statements can be used in DTL to conditionally display content.

* DTL can use for loops to go through lists.

* URLs can be referenced with just the path name if the page is within the application. This only works with predefined paths and you should watch for any arguments that need to be passed.

* Filters are useful for modifying variables within a template as you won’t have to write too much extra code to modify the variable yourself.

* Some filters require arguments, so make sure that any filter used does not require any arguments.

* Some filters also only work with specific data types, so make sure to research a filter before using one by looking at the documentation for the filter.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MODELS AND DATABASES

CREATING A MODEL

Every time we create a new app, Django provides us with a folder structure for our work which includes a file called models.py with the following starter code:

###

from django.db import models

###


To create a model, we write a class, like so:

###

class Flower(models.Model):
  ## Define attributes here
  pass

###

Notice that our model actually inherits from the Model parent class django.db.models.Model module. These models will later inform the 
database to use this schema to build its tables


model.py example:

###

from django.db import models

# Create your models here.
class Owner(models.Model):
  pass

class Patient(models.Model):
  pass

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

ADDING MODEL FIELDS

As we mentioned, models are used to represent real-life objects. We can mimic and create object attributes in our models using fields. 

Fields have names and are assigned a type. For example, a Flower model can have a petal_color field that expects a string:

###

class Flower(models.Model):
  petal_color = models.CharField()

###


Django uses specific field types to match the expected data with what will go into the database. 

Above, we used the .CharField() type to store a short string. We can continue to add to our model and include other attributes, like petal_number.


###

class Flower(models.Model):
  petal_color = models.CharField()
  petal_number = models.IntegerField()
  # More attributes… 

###


Since we want petal_number to be a number, we used the .IntegerField() field type. 
Django provides a huge variety of field types for us to specify the data types of our model attributes, check out theField Types Documentation to 
explore the entire list of possibilities!

https://docs.djangoproject.com/en/3.1/ref/models/fields/#model-field-types


We might also want to add constraints to our fields. 

For example, we might want our petal_color field to have a max length of 20 characters. We can supply an argument like so:


###

class Flower(models.Model):
  petal_color = models.CharField(max_length=20)
  petal_number = models.IntegerField(default=0)

###


These arguments give us finer control over what data we want to include in our database. 

For .CharField() we used max_length to limit the number of acceptable characters to 20. We can even set default values, like for petal_number, 
we set default=0 meaning if we didn’t provide a value for petal_number the value is automatically 0.


code example: (inside of models.py)

###

from django.db import models

class Owner(models.Model):
  # Delete pass and add the Owner fields
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)
  phone = models.CharField(max_length=30)

class Patient(models.Model):
  # Delete pass and add the Patient fields
  breed = models.CharField(max_length=200)
  pet_name = models.CharField(max_length=200)
  age = models.IntegerField(default=0)

###


----------------------------------------------------------------------------------------------------------------------------------------------------------------

PRIMARY KEY, FOREIGN KEY, AND RELATIONSHIPS


Later on, we’ll use these models to create instances (specific model objects) in our database. 
With a Flower model, we could create instances with characteristics of flowers like a rose, a sunflower, or a daisy. 
Instances then correspond to rows, or records, in our database.


We’d also need our instances to have a unique ID to help us keep track of each one. 
These IDs are called primary keys and Django helps us automatically create these unique IDs by incrementing by 1 each time. 
For example, if our first Flower instance is rose, it would have a primary key/ID of 1. 
The second instance, sunflower, a primary key of 2 — then maybe a daisy with a primary key of 3, and so forth.


In our apps, we often create multiple models that relate to each other in some way. 
For our example Flower model, we could have a gardener tend to flowers! This means we need to create another model called Gardener:


###

class Gardener(models.Model):
  first_name = models.CharField(max_length=20)
  years_experience = models.IntegerField()

###


Now the question is how do we show this relationship between Flower and Gardener? 

Well, let’s say that a Gardener instance can tend to multiple Flower instances, but a Flower instance can only have a single Gardener. 

This means we have a One to Many relationship, one Gardener for multiple Flowers. Conversely, Flowers have a Many to One relationship with a Gardener.


To make this connection known, we need to supply Flower with a foreign key of a Gardner, i.e. the Flower instances know which Gardener instance takes care of it.


###

# Garden has a one-to-many relationship with Flower
class Gardener(models.Model):
  first_name = models.CharField(max_length=20)
  years_experience = models.IntegerField()
 
# Flower has a many-to-one relationship with Gardener
class Flower(models.Model):
  petal_color = models.CharField(max_length=10)
  petal_number = models.IntegerField()
  gardener = models.ForeignKey(Gardener, on_delete=models.CASCADE) 

###


Notice that we added the gardener field using models.ForeignKey() and with arguments. 

The first argument is Gardener because that’s the model we want this foreign key to come from. 

Then we add on_delete=models.CASCADE to let Django know to delete the Flower instance if its connected Gardener instance is deleted. 


Hypothetically, we could even supply Gardener with a foreign key as well if we wanted to link Gardener to another model, like a Garden for example! 

These foreign keys tell the database that a one-to-many relationship exists and the direction of this relationship. 

There are other types of relationships, but let’s implement a one-to-many relationship with our own models!

https://docs.djangoproject.com/en/3.1/topics/db/examples/



----------------------------------------------------------------------------------------------------------------------------------------------------------------

FIELD TYPE OPTIONAL ARGUMENTS


We can continue to customize our models by supplying fields with options, that specify how data can be inserted into the database. 

Django provides field option documentation, which shows a huge list of these options. Let’s go over some common ones together!

https://docs.djangoproject.com/en/3.1/topics/db/models/#field-options


One common option is null that can take on a value of True or False. This null option tells the database if a field can be left intentionally void of information. 

By default, Django sets null=False. However, we can override the default and set null=True. Here’s an example:


###

class Flower(model.Model):
  petal_number = models.IntegerField(max_length=20, null=True)
  # Other fields

###


With the code above, when we create a Flower instance, we can set petal_number to null.

Another common option is blank, which is similar to null, but setting blank to True means a field doesn’t have to take anything, not even a null value. 

By default blank is False.


###

class Flower(model.Model):
  nickname = models.CharField(max_length=20, blank=True)
  # Other fields

###


Now, when we create a Flower instance, we can leave the nickname field blank.

The last one we’ll touch upon is choices which limits the input a field can accept. 

We can set choices by creating a list of tuples that contain 2 items: a key and a value. Take for example


###

class Flower(models.Model):
  COLOR_CHOICES = [
     ("R", "Red"),
     ("Y", "Yellow"),
     ("P", "Purple"),
     ("O", "Other"),
  ]
 
  color = models.CharField(max_length=1, choices=COLOR_CHOICES)
  # Other fields

###


For our Flower instance, we can specify its color with the limited choices provided — meaning our color field can only be assigned "R" (for "Red"), 

"Y" (for "Yellow"), or "P" (for "Purple"), or "O" (for "Other" from the COLOR_CHOICES list. With choices we know exactly what data we can accept from users.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

MODEL METADATA

We’ve supplied our models with plenty of fields and data, but what about metadata? Let’s first define it.

Metadata is an optional entity within a model and it is anything that is not a field. 
Some helpful metadata can include how to order instances, create human-readable names, providing a database table name, and more.

https://docs.djangoproject.com/en/3.1/ref/models/options/#model-meta-options

***

Data that provide information about other data. Metadata summarizes basic information about data, making finding & working with particular instances of data easier. 
Metadata can be created manually to be more accurate, or automatically and contain more basic information

***


To add metadata to a model, we’ll need to nest another class called Meta inside the model’s class definition. Let’s use metadata to order instances as an example:

###

class Flower(models.Model):
  name = models.CharField(max_length=10)
  # All the other attributes
 
  class Meta:
    ordering = ["name"]

###


In this case, we created an attribute, ordering which takes a list of strings (["name"]) that determine the ordering. 
Later on, when we need to search for Flower instances, the database will return back a list with the list ordered by the name field. 
We can even reverse the order by adding a - in front of a string like ["-name"].


Other metadata work in a similar fashion. Let’s try adding a verbose human-readable name:

###

class TropicalFlower(models.Model):
  # Fields and Methods
 
  class Meta:
    verbose_name = "tropical flower" 

###


Without setting this metadata, our model’s name would be tropical_flower by default, here we’ve assigned the verbose name to be "tropical flower". 

While our change was subtle, we could provide even more detail to inform other developers about our model.







